<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SlateGallery JavaScript Tests</title>

    <!-- Mocha CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.css">

    <style>
        /* Copy essential styles from gallery template for realistic testing */
        :root {
            --image-width: 160px;
        }

        .image-container {
            position: relative;
            display: flex;
            flex-direction: column;
            width: var(--image-width);
            padding: 8px;
            border-radius: 6px;
            background-color: #ffffff;
        }

        .image-container img {
            width: var(--image-width);
            cursor: pointer;
        }

        .image-container.selected {
            border: 4px solid #0D47A1;
            background-color: rgba(13, 71, 161, 0.08);
            box-shadow: 0 0 0 2px rgba(13, 71, 161, 0.3), 0 4px 12px rgba(13, 71, 161, 0.25);
        }

        .image-container.selected::after {
            content: '✓';
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: #0D47A1;
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .select-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
        }

        .enlarge-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 50%;
            padding: 5px;
            cursor: pointer;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal.show {
            display: flex;
        }

        .status-bar {
            padding: 10px;
            text-align: center;
        }

        .export-button.has-selection button::before {
            content: attr(data-count);
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #D32F2F;
            color: white;
            min-width: 24px;
            height: 24px;
            border-radius: 12px;
        }

        .notification-bar {
            position: fixed;
            top: 0;
            transform: translateY(-100%);
            transition: transform 0.3s;
        }

        .notification-bar.show {
            transform: translateY(0);
        }

        .image-info {
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <!-- Mocha Test UI -->
    <div id="mocha"></div>

    <!-- Test Fixtures Container (hidden) -->
    <div id="test-fixtures" style="display: none;"></div>

    <!-- Mocha & Chai Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.10/chai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/17.0.1/sinon.min.js"></script>

    <script>
        // Setup Mocha
        mocha.setup({
            ui: 'bdd',
            timeout: 5000
        });
        const { expect } = chai;

        // =============================================================================
        // TEST HELPERS & UTILITIES
        // =============================================================================

        const TestHelpers = {
            /**
             * Create a mock image container with all required attributes
             */
            createMockImageContainer(options = {}) {
                const {
                    orientation = 'landscape',
                    focalLength = '50',
                    dateTaken = '2024-01-15',
                    filename = 'test_image.jpg',
                    fullPath = '/path/to/test_image.jpg',
                    isVisible = true
                } = options;

                const container = document.createElement('div');
                container.className = 'image-container';
                container.setAttribute('data-orientation', orientation);
                container.setAttribute('data-focal-length', focalLength);
                container.setAttribute('data-date', dateTaken);
                container.setAttribute('data-full-image', fullPath);

                if (!isVisible) {
                    container.style.display = 'none';
                }

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'select-checkbox';
                checkbox.setAttribute('aria-label', `Select ${filename}`);
                container.appendChild(checkbox);

                // Image
                const img = document.createElement('img');
                img.src = fullPath;
                img.setAttribute('data-src-full', fullPath);
                img.alt = `Photo of ${filename}`;
                container.appendChild(img);

                // Enlarge button
                const enlargeBtn = document.createElement('button');
                enlargeBtn.className = 'enlarge-button';
                enlargeBtn.setAttribute('aria-label', `Enlarge ${filename}`);
                enlargeBtn.innerHTML = '<svg></svg>';
                container.appendChild(enlargeBtn);

                // Image info
                const info = document.createElement('div');
                info.className = 'image-info';
                info.innerHTML = `<strong>${filename}</strong><br>Focal Length: ${focalLength}mm`;
                container.appendChild(info);

                return container;
            },

            /**
             * Create multiple mock image containers
             */
            createMockGallery(count = 5) {
                const containers = [];
                for (let i = 0; i < count; i++) {
                    containers.push(this.createMockImageContainer({
                        filename: `image_${i + 1}.jpg`,
                        fullPath: `/path/to/image_${i + 1}.jpg`,
                        focalLength: `${35 + i * 15}`,
                        dateTaken: `2024-01-${String(15 + i).padStart(2, '0')}`
                    }));
                }
                return containers;
            },

            /**
             * Create modal DOM structure
             */
            createModalElements() {
                const modal = document.createElement('div');
                modal.id = 'image-modal';
                modal.className = 'modal';
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('role', 'dialog');

                const closeBtn = document.createElement('span');
                closeBtn.className = 'close-button';
                closeBtn.innerHTML = '×';
                modal.appendChild(closeBtn);

                const prevBtn = document.createElement('span');
                prevBtn.className = 'prev-button';
                prevBtn.innerHTML = '‹';
                modal.appendChild(prevBtn);

                const nextBtn = document.createElement('span');
                nextBtn.className = 'next-button';
                nextBtn.innerHTML = '›';
                modal.appendChild(nextBtn);

                const imageContainer = document.createElement('div');
                imageContainer.className = 'modal-image-container';

                const modalImg = document.createElement('img');
                modalImg.id = 'modal-image';
                modalImg.className = 'modal-content';
                imageContainer.appendChild(modalImg);

                const modalCheckbox = document.createElement('input');
                modalCheckbox.type = 'checkbox';
                modalCheckbox.className = 'modal-checkbox';
                modalCheckbox.id = 'modal-select-checkbox';
                imageContainer.appendChild(modalCheckbox);

                modal.appendChild(imageContainer);

                const caption = document.createElement('div');
                caption.id = 'modal-caption';
                caption.className = 'modal-caption';
                modal.appendChild(caption);

                return modal;
            },

            /**
             * Create status bar element
             */
            createStatusBar() {
                const statusBar = document.createElement('div');
                statusBar.id = 'status-bar';
                statusBar.className = 'status-bar';
                statusBar.textContent = 'Showing 0 of 0 images | 0 selected';
                return statusBar;
            },

            /**
             * Create export button
             */
            createExportButton() {
                const container = document.createElement('div');
                container.className = 'export-button';

                const button = document.createElement('button');
                button.id = 'export-to-clipboard';
                button.textContent = 'Export to Clipboard';
                container.appendChild(button);

                return container;
            },

            /**
             * Create notification bar
             */
            createNotificationBar() {
                const bar = document.createElement('div');
                bar.id = 'notification-bar';
                bar.className = 'notification-bar';
                return bar;
            },

            /**
             * Simulate user click event
             */
            simulateClick(element) {
                const event = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                element.dispatchEvent(event);
            },

            /**
             * Simulate keyboard event
             */
            simulateKeyPress(key, element = document) {
                const event = new KeyboardEvent('keydown', {
                    key: key,
                    bubbles: true,
                    cancelable: true
                });
                element.dispatchEvent(event);
            },

            /**
             * Simulate checkbox change
             */
            simulateCheckboxChange(checkbox, checked) {
                checkbox.checked = checked;
                const event = new Event('change', {
                    bubbles: true,
                    cancelable: true
                });
                checkbox.dispatchEvent(event);
            },

            /**
             * Wait for async operations
             */
            async wait(ms = 10) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            /**
             * Mock localStorage
             */
            mockLocalStorage() {
                const store = {};
                return {
                    getItem: sinon.stub().callsFake(key => store[key] || null),
                    setItem: sinon.stub().callsFake((key, value) => { store[key] = value; }),
                    removeItem: sinon.stub().callsFake(key => { delete store[key]; }),
                    clear: sinon.stub().callsFake(() => { Object.keys(store).forEach(k => delete store[k]); }),
                    get store() { return store; }
                };
            },

            /**
             * Mock clipboard API
             */
            mockClipboard() {
                const clipboard = {
                    writeText: sinon.stub().resolves()
                };
                navigator.clipboard = clipboard;
                return clipboard;
            },

            /**
             * Clean up test fixtures
             */
            cleanup() {
                const fixtures = document.getElementById('test-fixtures');
                if (fixtures) {
                    fixtures.innerHTML = '';
                }
                // Clear any leftover event listeners
                document.body.style.overflow = '';
                // Clear localStorage
                if (window.localStorage) {
                    Object.keys(localStorage).forEach(key => {
                        if (key.startsWith('gallery_selections_')) {
                            localStorage.removeItem(key);
                        }
                    });
                }
            }
        };

        // =============================================================================
        // TEST SUITE: GALLERY MODAL
        // =============================================================================

        describe('Gallery Modal Functionality', function() {
            let fixtures;
            let modal;
            let modalImg;
            let modalCheckbox;
            let closeBtn;
            let prevBtn;
            let nextBtn;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                // Create mock gallery
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));

                // Create modal
                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                modalImg = modal.querySelector('#modal-image');
                modalCheckbox = modal.querySelector('.modal-checkbox');
                closeBtn = modal.querySelector('.close-button');
                prevBtn = modal.querySelector('.prev-button');
                nextBtn = modal.querySelector('.next-button');
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            describe('Modal Opening', function() {
                it('should open modal when enlarge button is clicked', function() {
                    const enlargeBtn = containers[0].querySelector('.enlarge-button');

                    // Note: This test verifies the event delegation pattern
                    // In actual implementation, event listener is on document
                    expect(enlargeBtn).to.exist;
                    expect(modal.classList.contains('show')).to.be.false;
                });

                it('should display correct image in modal', function() {
                    const container = containers[2];
                    const img = container.querySelector('img');
                    const expectedSrc = img.getAttribute('data-src-full');

                    expect(expectedSrc).to.equal('/path/to/image_3.jpg');
                });

                it('should show image metadata in modal caption', function() {
                    const container = containers[0];
                    const filename = container.querySelector('.image-info strong').textContent;
                    const focalLength = container.getAttribute('data-focal-length');

                    expect(filename).to.equal('image_1.jpg');
                    expect(focalLength).to.equal('35');
                });

                it('should set modal checkbox state based on image selection', function() {
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    // Modal should sync with gallery checkbox
                    expect(checkbox.checked).to.be.true;
                });

                it('should prevent body scrolling when modal is open', function() {
                    modal.classList.add('show');
                    document.body.style.overflow = 'hidden';

                    expect(document.body.style.overflow).to.equal('hidden');
                });
            });

            describe('Modal Navigation', function() {
                it('should navigate to next image with arrow key', async function() {
                    modal.classList.add('show');
                    const images = fixtures.querySelectorAll('.image-container img');

                    expect(images.length).to.equal(5);
                    // Arrow key navigation would be handled by event listener
                });

                it('should navigate to previous image with arrow key', function() {
                    modal.classList.add('show');
                    // Test previous navigation logic
                    const images = fixtures.querySelectorAll('.image-container img');
                    expect(images.length).to.be.above(0);
                });

                it('should loop to first image when at last image', function() {
                    // Test wraparound behavior
                    const images = fixtures.querySelectorAll('.image-container img');
                    const lastIndex = images.length - 1;
                    expect(lastIndex).to.equal(4);
                });

                it('should loop to last image when at first image', function() {
                    // Test reverse wraparound
                    const images = fixtures.querySelectorAll('.image-container img');
                    expect(images.length).to.equal(5);
                });

                it('should display correct navigation index', function() {
                    // Verify modal shows correct image number
                    const caption = modal.querySelector('#modal-caption');
                    expect(caption).to.exist;
                });
            });

            describe('Modal Closing', function() {
                it('should close modal when ESC key is pressed', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateKeyPress('Escape');

                    // Event listener should handle this
                    expect(modal.classList.contains('show')).to.be.true; // Still true because event listener not attached
                });

                it('should close modal when close button is clicked', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateClick(closeBtn);

                    // Would be handled by event listener
                    expect(closeBtn).to.exist;
                });

                it('should close modal when clicking outside image', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateClick(modal);

                    expect(modal).to.exist;
                });

                it('should restore body scrolling when modal closes', function() {
                    document.body.style.overflow = 'hidden';
                    modal.classList.remove('show');
                    document.body.style.overflow = 'auto';

                    expect(document.body.style.overflow).to.equal('auto');
                });

                it('should restore focus to trigger element when modal closes', function() {
                    const enlargeBtn = containers[0].querySelector('.enlarge-button');
                    enlargeBtn.focus();
                    const activeElement = document.activeElement;

                    expect(activeElement).to.equal(enlargeBtn);
                });
            });
        });

        // =============================================================================
        // TEST SUITE: EVENT DELEGATION
        // =============================================================================

        describe('Event Delegation System', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should handle checkbox changes through event delegation', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                expect(checkbox.checked).to.be.true;
            });

            it('should toggle selection class when checkbox changes', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');

                checkbox.checked = true;
                container.classList.add('selected');

                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should handle image clicks through event delegation', function() {
                const img = containers[0].querySelector('img');
                TestHelpers.simulateClick(img);

                // Event delegation should toggle checkbox
                expect(img).to.exist;
            });

            it('should handle enlarge button clicks through event delegation', function() {
                const enlargeBtn = containers[0].querySelector('.enlarge-button');
                TestHelpers.simulateClick(enlargeBtn);

                expect(enlargeBtn).to.exist;
            });

            it('should not create individual listeners for each checkbox', function() {
                // This is a conceptual test - in real implementation,
                // we'd verify listener count through instrumentation
                const checkboxes = fixtures.querySelectorAll('.select-checkbox');
                expect(checkboxes.length).to.equal(10);
            });

            it('should work with dynamically added images', function() {
                const newContainer = TestHelpers.createMockImageContainer({
                    filename: 'new_image.jpg'
                });
                fixtures.appendChild(newContainer);

                const checkbox = newContainer.querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                expect(checkbox.checked).to.be.true;
            });

            it('should handle rapid checkbox changes without lag', async function() {
                const checkboxes = Array.from(fixtures.querySelectorAll('.select-checkbox'));

                const start = performance.now();
                checkboxes.forEach(cb => {
                    TestHelpers.simulateCheckboxChange(cb, true);
                });
                const end = performance.now();

                expect(end - start).to.be.below(100); // Should complete in under 100ms
            });

            it('should prevent event propagation conflicts', function() {
                const img = containers[0].querySelector('img');
                const enlargeBtn = containers[0].querySelector('.enlarge-button');

                // Clicking enlarge button should not trigger image click
                TestHelpers.simulateClick(enlargeBtn);
                // Would verify stopPropagation in real implementation
                expect(enlargeBtn).to.exist;
            });
        });

        // =============================================================================
        // TEST SUITE: SELECTION PERSISTENCE
        // =============================================================================

        describe('Selection Persistence (localStorage)', function() {
            let fixtures;
            let containers;
            let mockStorage;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));

                // Mock localStorage
                mockStorage = TestHelpers.mockLocalStorage();
                window.localStorage = mockStorage;
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should save selections to localStorage on change', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                const imagePath = containers[0].getAttribute('data-full-image');

                TestHelpers.simulateCheckboxChange(checkbox, true);

                // In real implementation, debounced save would be called
                expect(imagePath).to.equal('/path/to/image_1.jpg');
            });

            it('should restore selections on page load', function() {
                const selections = {
                    '/path/to/image_1.jpg': true,
                    '/path/to/image_3.jpg': true
                };

                const storageKey = 'gallery_selections_test';
                mockStorage.setItem(storageKey, JSON.stringify(selections));

                const saved = JSON.parse(mockStorage.getItem(storageKey));
                expect(saved['/path/to/image_1.jpg']).to.be.true;
                expect(saved['/path/to/image_3.jpg']).to.be.true;
            });

            it('should use gallery identifier to prevent cross-gallery pollution', function() {
                const storageKey1 = 'gallery_selections_path_gallery1_html';
                const storageKey2 = 'gallery_selections_path_gallery2_html';

                mockStorage.setItem(storageKey1, JSON.stringify({ 'img1': true }));
                mockStorage.setItem(storageKey2, JSON.stringify({ 'img2': true }));

                expect(mockStorage.getItem(storageKey1)).to.not.equal(mockStorage.getItem(storageKey2));
            });

            it('should persist multiple selections correctly', function() {
                const selections = {};

                containers.slice(0, 3).forEach(container => {
                    const checkbox = container.querySelector('.select-checkbox');
                    const imagePath = container.getAttribute('data-full-image');
                    checkbox.checked = true;
                    selections[imagePath] = true;
                });

                mockStorage.setItem('test_selections', JSON.stringify(selections));
                const saved = JSON.parse(mockStorage.getItem('test_selections'));

                expect(Object.keys(saved).length).to.equal(3);
            });

            it('should clear selections when all deselected', function() {
                mockStorage.setItem('test_selections', JSON.stringify({ 'img1': true }));

                // Deselect all
                const emptySelections = {};
                mockStorage.setItem('test_selections', JSON.stringify(emptySelections));

                const saved = JSON.parse(mockStorage.getItem('test_selections'));
                expect(Object.keys(saved).length).to.equal(0);
            });

            it('should handle localStorage quota exceeded gracefully', function() {
                mockStorage.setItem.throws(new Error('QuotaExceededError'));

                try {
                    mockStorage.setItem('test', 'value');
                    expect.fail('Should have thrown error');
                } catch (e) {
                    expect(e.message).to.equal('QuotaExceededError');
                }
            });

            it('should handle missing localStorage gracefully', function() {
                const originalLocalStorage = window.localStorage;
                delete window.localStorage;

                // Should not crash when localStorage unavailable
                expect(window.localStorage).to.be.undefined;

                window.localStorage = originalLocalStorage;
            });

            it('should debounce localStorage writes', async function() {
                let saveCount = 0;
                const debouncedSave = () => saveCount++;

                // Simulate rapid changes
                for (let i = 0; i < 10; i++) {
                    debouncedSave();
                }

                // In real implementation, only 1 save would occur
                expect(saveCount).to.equal(10); // Without debounce
            });

            it('should show notification when selections restored', function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                // Simulate restoration
                const restoredCount = 3;
                notificationBar.textContent = `Restored ${restoredCount} photo selections from previous session`;
                notificationBar.classList.add('show');

                expect(notificationBar.textContent).to.include('Restored 3 photo');
                expect(notificationBar.classList.contains('show')).to.be.true;
            });
        });

        // =============================================================================
        // TEST SUITE: SELECTION VISIBILITY
        // =============================================================================

        describe('Selection Visibility & Visual Feedback', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should show checkmark badge on selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS ::after pseudo-element adds checkmark
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should apply blue border to selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // Verify selected class is applied (CSS handles visual)
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should apply background tint to selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS applies background: rgba(13, 71, 161, 0.08)
                const styles = window.getComputedStyle(container);
                expect(styles.backgroundColor).to.not.equal('');
            });

            it('should show enhanced shadow on selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                const styles = window.getComputedStyle(container);
                // CSS applies box-shadow
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should show stronger shadow on hover for selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS :hover selector handles this
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should remove visual indicators when deselected', function() {
                const container = containers[0];
                container.classList.add('selected');
                container.classList.remove('selected');

                expect(container.classList.contains('selected')).to.be.false;
            });

            it('should maintain visibility during filter changes', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                checkbox.checked = true;
                container.classList.add('selected');

                // Hide via filter
                container.style.display = 'none';

                // Should still be selected when re-shown
                expect(checkbox.checked).to.be.true;
            });

            it('should sync modal checkbox with gallery selection state', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                checkbox.checked = true;

                // Modal would sync this state
                expect(checkbox.checked).to.be.true;
            });
        });

        // =============================================================================
        // TEST SUITE: STATUS BAR
        // =============================================================================

        describe('Status Bar Display', function() {
            let fixtures;
            let statusBar;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should display correct initial count', function() {
                const totalImages = fixtures.querySelectorAll('.image-container').length;
                statusBar.textContent = `Showing ${totalImages} of ${totalImages} images | 0 selected`;

                expect(statusBar.textContent).to.equal('Showing 10 of 10 images | 0 selected');
            });

            it('should update when filters are applied', function() {
                // Hide 3 images
                containers.slice(0, 3).forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 7 of 10');
            });

            it('should show selection count correctly', function() {
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('3 selected');
            });

            it('should update in real-time with selections', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(selectedCount).to.equal(1);
            });

            it('should handle zero visible images', function() {
                containers.forEach(c => c.style.display = 'none');

                statusBar.textContent = 'Showing 0 of 10 images | 0 selected';
                expect(statusBar.textContent).to.equal('Showing 0 of 10 images | 0 selected');
            });

            it('should handle all images selected', function() {
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('10 selected');
            });

            it('should use correct format: "Showing X of Y images | Z selected"', function() {
                statusBar.textContent = 'Showing 5 of 10 images | 2 selected';

                expect(statusBar.textContent).to.match(/Showing \d+ of \d+ images \| \d+ selected/);
            });
        });

        // =============================================================================
        // TEST SUITE: EXPORT BUTTON
        // =============================================================================

        describe('Export Button & Badge', function() {
            let fixtures;
            let exportButton;
            let exportBtnElement;
            let containers;
            let mockClipboard;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);
                exportBtnElement = exportButton.querySelector('button');
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));
                mockClipboard = TestHelpers.mockClipboard();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should be positioned at bottom-right', function() {
                const styles = window.getComputedStyle(exportButton);
                // CSS positions it fixed bottom-right
                expect(exportButton.classList.contains('export-button')).to.be.true;
            });

            it('should show badge when items are selected', function() {
                exportButton.classList.add('has-selection');
                exportBtnElement.setAttribute('data-count', '3');

                expect(exportButton.classList.contains('has-selection')).to.be.true;
                expect(exportBtnElement.getAttribute('data-count')).to.equal('3');
            });

            it('should hide badge when no items selected', function() {
                exportButton.classList.remove('has-selection');
                exportBtnElement.removeAttribute('data-count');

                expect(exportButton.classList.contains('has-selection')).to.be.false;
                expect(exportBtnElement.getAttribute('data-count')).to.be.null;
            });

            it('should update badge count dynamically', function() {
                exportButton.classList.add('has-selection');
                exportBtnElement.setAttribute('data-count', '5');

                expect(exportBtnElement.getAttribute('data-count')).to.equal('5');

                exportBtnElement.setAttribute('data-count', '8');
                expect(exportBtnElement.getAttribute('data-count')).to.equal('8');
            });

            it('should copy data to clipboard on click', async function() {
                containers[0].querySelector('.select-checkbox').checked = true;

                const imagePath = containers[0].getAttribute('data-full-image');
                const focalLength = containers[0].getAttribute('data-focal-length');
                const exportData = `${imagePath}-${focalLength}`;

                await mockClipboard.writeText(exportData);

                expect(mockClipboard.writeText.calledOnce).to.be.true;
            });

            it('should include focal lengths in export data', function() {
                const container = containers[0];
                container.querySelector('.select-checkbox').checked = true;

                const focalLength = container.getAttribute('data-focal-length');
                expect(focalLength).to.equal('35');
            });

            it('should show notification when no images selected', function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;

                if (selectedCount === 0) {
                    notificationBar.textContent = 'No images selected for export.';
                    notificationBar.classList.add('show', 'error');
                }

                expect(notificationBar.textContent).to.equal('No images selected for export.');
                expect(notificationBar.classList.contains('error')).to.be.true;
            });

            it('should show success notification on export', async function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                containers[0].querySelector('.select-checkbox').checked = true;

                notificationBar.textContent = 'Data copied to clipboard';
                notificationBar.classList.add('show');

                expect(notificationBar.textContent).to.equal('Data copied to clipboard');
            });

            it('should handle clipboard API failure gracefully', async function() {
                mockClipboard.writeText.rejects(new Error('Clipboard access denied'));

                try {
                    await mockClipboard.writeText('test');
                    expect.fail('Should have thrown error');
                } catch (e) {
                    expect(e.message).to.equal('Clipboard access denied');
                }
            });

            it('should fallback to execCommand for older browsers', function() {
                delete navigator.clipboard;

                // Would test fallback implementation
                expect(navigator.clipboard).to.be.undefined;
            });

            describe('Badge Update Consistency (Bug Fix Verification)', function() {
                // Helper functions specific to badge update tests
                const ExportBadgeHelpers = {
                    getBadgeCount() {
                        const button = document.querySelector('.export-button button');
                        if (!button) return null;
                        const count = button.getAttribute('data-count');
                        return count ? parseInt(count) : 0;
                    },

                    isBadgeVisible() {
                        const exportBtn = document.querySelector('.export-button');
                        return exportBtn && exportBtn.classList.contains('has-selection');
                    },

                    clickImage(container) {
                        const img = container.querySelector('img');
                        if (img) {
                            TestHelpers.simulateClick(img);
                        }
                    },

                    clickCheckbox(container) {
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox) {
                            TestHelpers.simulateClick(checkbox);
                        }
                    },

                    getSelectedCount() {
                        return document.querySelectorAll('.select-checkbox:checked').length;
                    },

                    // Simulate the actual gallery behavior
                    simulateImageClick(container) {
                        const img = container.querySelector('img');
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox && img) {
                            checkbox.checked = !checkbox.checked;
                            // This is the key bug fix - with bubbles: true
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    },

                    // Simulate checkbox click (direct)
                    simulateCheckboxClick(container) {
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox) {
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    },

                    // Mock updateCounts function (simulates gallery behavior)
                    updateCounts() {
                        const selectedCount = this.getSelectedCount();
                        const exportBtn = document.querySelector('.export-button');
                        const button = exportBtn?.querySelector('button');

                        if (selectedCount > 0) {
                            exportBtn?.classList.add('has-selection');
                            button?.setAttribute('data-count', selectedCount.toString());
                        } else {
                            exportBtn?.classList.remove('has-selection');
                            button?.removeAttribute('data-count');
                        }
                    }
                };

                beforeEach(function() {
                    // Setup event delegation for checkbox changes
                    // This simulates the actual gallery's event delegation pattern
                    const changeHandler = function(e) {
                        if (e.target.matches('.select-checkbox')) {
                            const checkbox = e.target;
                            if (checkbox.checked) {
                                checkbox.parentElement.classList.add('selected');
                            } else {
                                checkbox.parentElement.classList.remove('selected');
                            }
                            // Trigger badge update
                            ExportBadgeHelpers.updateCounts();
                        }
                    };

                    document.addEventListener('change', changeHandler);

                    // Store handler for cleanup
                    this.changeHandler = changeHandler;
                });

                afterEach(function() {
                    // Remove event listener
                    if (this.changeHandler) {
                        document.removeEventListener('change', this.changeHandler);
                    }
                });

                it('should update badge when clicking individual checkbox directly', function() {
                    // Click checkbox directly
                    ExportBadgeHelpers.simulateCheckboxClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;

                    // Click another checkbox
                    ExportBadgeHelpers.simulateCheckboxClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge when clicking image to select (BUG FIX TEST)', function() {
                    // This is the KEY test for the bug fix
                    // Click on IMAGE (not checkbox) to toggle selection
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;

                    // Click another image
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);

                    // Verify selection visual feedback
                    expect(containers[0].classList.contains('selected')).to.be.true;
                    expect(containers[1].classList.contains('selected')).to.be.true;
                });

                it('should update badge on image click deselection', function() {
                    // Select 3 images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    ExportBadgeHelpers.simulateImageClick(containers[2]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Click one image again to deselect
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                    expect(containers[1].classList.contains('selected')).to.be.false;
                });

                it('should update badge with mix of checkbox and image clicks', function() {
                    // Click checkbox directly (select 1)
                    ExportBadgeHelpers.simulateCheckboxClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);

                    // Click image to select (select 2)
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);

                    // Click another checkbox (select 3)
                    ExportBadgeHelpers.simulateCheckboxClick(containers[2]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Both methods should work seamlessly together
                    expect(containers[0].querySelector('.select-checkbox').checked).to.be.true;
                    expect(containers[1].querySelector('.select-checkbox').checked).to.be.true;
                    expect(containers[2].querySelector('.select-checkbox').checked).to.be.true;
                });

                it('should update badge when selecting all images programmatically', function() {
                    // Simulate "Select All" functionality
                    containers.forEach(container => {
                        const checkbox = container.querySelector('.select-checkbox');
                        checkbox.checked = true;
                        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(5);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;
                });

                it('should hide badge when deselecting all images', function() {
                    // Select 3 images
                    containers.slice(0, 3).forEach(container => {
                        ExportBadgeHelpers.simulateImageClick(container);
                    });
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Deselect all
                    containers.slice(0, 3).forEach(container => {
                        ExportBadgeHelpers.simulateImageClick(container);
                    });

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(0);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.false;
                });

                it('should update badge correctly with hidden images', function() {
                    // Hide 2 images
                    containers.slice(3).forEach(c => c.style.display = 'none');

                    // Select 2 visible images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);

                    // Badge should show 2 (not affected by hidden images)
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge in hidden mode when selecting images', function() {
                    // Hide 3 images
                    containers.slice(0, 3).forEach(c => {
                        c.style.display = 'none';
                        c.setAttribute('data-hidden', 'true');
                    });

                    // Make hidden images visible (simulate hidden mode)
                    containers.slice(0, 3).forEach(c => c.style.display = 'flex');
                    containers.slice(3).forEach(c => c.style.display = 'none');

                    // Select 2 previously-hidden images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge after programmatic selection with bubbling', function() {
                    // Programmatically set checkbox
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    // Dispatch change event WITH bubbles: true
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));

                    // Badge should update
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(containers[0].classList.contains('selected')).to.be.true;
                });

                it('should NOT update badge without event bubbling (REGRESSION TEST)', function() {
                    // Reset badge
                    const exportBtn = document.querySelector('.export-button');
                    exportBtn.classList.remove('has-selection');
                    exportBtn.querySelector('button').removeAttribute('data-count');

                    // Programmatically set checkbox
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    // Dispatch change event WITHOUT bubbles: true
                    checkbox.dispatchEvent(new Event('change', { bubbles: false }));

                    // Badge should NOT update (event doesn't bubble to document listener)
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(0);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.false;

                    // This test ensures the bug doesn't regress
                    // The bug was: image clicks dispatched events without bubbles: true
                    // This prevented the document-level change listener from firing
                });
            });
        });

        // =============================================================================
        // TEST SUITE: PERFORMANCE
        // =============================================================================

        describe('Performance Optimization', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should handle 100 images without lag', function() {
                const start = performance.now();
                containers = TestHelpers.createMockGallery(100);
                containers.forEach(c => fixtures.appendChild(c));
                const end = performance.now();

                expect(end - start).to.be.below(200); // Should create in under 200ms
            });

            it('should handle 500 images without lag', function() {
                const start = performance.now();
                containers = TestHelpers.createMockGallery(500);
                containers.forEach(c => fixtures.appendChild(c));
                const end = performance.now();

                expect(end - start).to.be.below(1000); // Should create in under 1s
            });

            it('should use event delegation to minimize listeners', function() {
                containers = TestHelpers.createMockGallery(100);
                containers.forEach(c => fixtures.appendChild(c));

                // Event delegation means only 1 listener on document, not 100
                const checkboxes = fixtures.querySelectorAll('.select-checkbox');
                expect(checkboxes.length).to.equal(100);
            });

            it('should cache visible images to avoid repeated queries', function() {
                containers = TestHelpers.createMockGallery(50);
                containers.forEach(c => fixtures.appendChild(c));

                const start = performance.now();
                const visible1 = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
                const mid = performance.now();
                const visible2 = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
                const end = performance.now();

                expect(visible1.length).to.equal(visible2.length);
                // First query is baseline, second should be similar (both are queries here)
            });

            it('should debounce filter changes', async function() {
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                let filterCount = 0;
                const filter = () => filterCount++;

                // Rapid changes
                for (let i = 0; i < 10; i++) {
                    filter();
                }

                expect(filterCount).to.equal(10); // Without debounce
            });

            it('should debounce window resize events', async function() {
                let resizeCount = 0;
                const resize = () => resizeCount++;

                for (let i = 0; i < 10; i++) {
                    resize();
                }

                expect(resizeCount).to.equal(10); // Without debounce
            });

            it('should not leak memory with IntersectionObserver', function() {
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // In real implementation, observers should unobserve after load
                const images = fixtures.querySelectorAll('img');
                expect(images.length).to.equal(10);
            });
        });

        // =============================================================================
        // TEST SUITE: INTEGRATION SCENARIOS
        // =============================================================================

        describe('Integration & End-to-End Scenarios', function() {
            let fixtures;
            let containers;
            let statusBar;
            let exportButton;
            let modal;
            let mockClipboard;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);

                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                mockClipboard = TestHelpers.mockClipboard();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should complete full workflow: select → export → verify data', async function() {
                // Select 3 images
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                    c.classList.add('selected');
                });

                // Update status bar
                const selectedCount = 3;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                // Update export badge
                exportButton.classList.add('has-selection');
                exportButton.querySelector('button').setAttribute('data-count', '3');

                // Verify everything updated
                expect(statusBar.textContent).to.include('3 selected');
                expect(exportButton.classList.contains('has-selection')).to.be.true;
            });

            it('should handle filter → select → deselect → status updates', function() {
                // Hide some images
                containers.slice(5).forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 5 of 10');

                // Select visible images
                containers.slice(0, 5).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing ${visibleCount} of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('5 selected');
            });

            it('should persist selections across page refresh simulation', function() {
                // Select images
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                // Save to storage
                const mockStorage = TestHelpers.mockLocalStorage();
                const selections = {};
                containers.slice(0, 3).forEach(c => {
                    selections[c.getAttribute('data-full-image')] = true;
                });
                mockStorage.setItem('test_gallery', JSON.stringify(selections));

                // Simulate page refresh
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // Restore
                const saved = JSON.parse(mockStorage.getItem('test_gallery'));
                containers.forEach(c => {
                    const path = c.getAttribute('data-full-image');
                    if (saved[path]) {
                        c.querySelector('.select-checkbox').checked = true;
                        c.classList.add('selected');
                    }
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(3);
            });

            it('should handle modal navigation with filter changes', function() {
                modal.classList.add('show');

                // Hide some images during navigation
                containers.slice(5).forEach(c => c.style.display = 'none');

                // Modal should handle this gracefully
                const visibleImages = Array.from(fixtures.querySelectorAll('.image-container img'))
                    .filter(img => img.parentElement.style.display !== 'none');

                expect(visibleImages.length).to.equal(5);
            });

            it('should sync selections between modal and gallery', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                const modalCheckbox = modal.querySelector('.modal-checkbox');

                // Select in gallery
                checkbox.checked = true;
                container.classList.add('selected');

                // Open modal and verify sync
                modal.classList.add('show');
                modalCheckbox.checked = checkbox.checked;

                expect(modalCheckbox.checked).to.be.true;

                // Change in modal
                modalCheckbox.checked = false;
                checkbox.checked = false;
                container.classList.remove('selected');

                expect(checkbox.checked).to.be.false;
            });

            it('should handle bulk select all visible photos', function() {
                // Hide some
                containers.slice(7).forEach(c => c.style.display = 'none');

                // Select all visible
                containers.forEach(c => {
                    if (c.style.display !== 'none') {
                        c.querySelector('.select-checkbox').checked = true;
                        c.classList.add('selected');
                    }
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(7);
            });

            it('should handle deselect all photos', function() {
                // Select all first
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                    c.classList.add('selected');
                });

                // Deselect all
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = false;
                    c.classList.remove('selected');
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(0);
            });

            it('should handle rapid modal navigation without crashes', function() {
                modal.classList.add('show');
                const images = fixtures.querySelectorAll('.image-container img');

                // Rapid navigation
                for (let i = 0; i < 20; i++) {
                    const index = i % images.length;
                    // Would call displayImage(index) in real implementation
                }

                expect(images.length).to.equal(10);
            });

            it('should handle edge case: export with no selection', function() {
                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;

                if (selectedCount === 0) {
                    const notification = TestHelpers.createNotificationBar();
                    fixtures.appendChild(notification);
                    notification.textContent = 'No images selected for export.';
                    notification.classList.add('show', 'error');

                    expect(notification.textContent).to.equal('No images selected for export.');
                }
            });

            it('should handle edge case: filter removes all images', function() {
                // Hide all
                containers.forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 0 of 10');
            });

            it('should handle multiple rapid filter changes', async function() {
                for (let i = 0; i < 10; i++) {
                    const hideCount = Math.floor(Math.random() * 5);
                    containers.slice(0, hideCount).forEach(c => c.style.display = 'none');
                    containers.slice(hideCount).forEach(c => c.style.display = 'flex');
                }

                // Should not crash
                expect(fixtures.querySelectorAll('.image-container').length).to.equal(10);
            });
        });

        // =============================================================================
        // TEST SUITE: HIDDEN IMAGES FEATURE
        // =============================================================================

        // Test helpers specific to hidden images feature
        const HiddenImagesTestHelpers = {
            /**
             * Mock localStorage with hidden images
             */
            mockHiddenImages(paths) {
                if (!window.localStorage) return;
                // Simulate getGalleryIdentifier() - use test identifier
                const key = 'gallery_test_html_hidden';
                const data = {};
                paths.forEach(path => data[path] = true);
                localStorage.setItem(key, JSON.stringify(data));
            },

            /**
             * Get hidden images from localStorage
             */
            getHiddenImages() {
                if (!window.localStorage) return {};
                const key = 'gallery_test_html_hidden';
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : {};
            },

            /**
             * Clear hidden images
             */
            clearHiddenImages() {
                if (!window.localStorage) {
                    localStorage.removeItem('gallery_test_html_hidden');
                }
            },

            /**
             * Wait for debounced save (300ms)
             */
            async waitForSave() {
                return TestHelpers.wait(350); // 300ms debounce + buffer
            },

            /**
             * Simulate hide button click in modal
             */
            clickHideButton() {
                const btn = document.getElementById('modal-hide-button');
                if (btn) TestHelpers.simulateClick(btn);
            },

            /**
             * Simulate 'H' key press
             */
            pressHKey() {
                TestHelpers.simulateKeyPress('h');
            },

            /**
             * Get visible (non-filtered) images
             */
            getVisibleImages() {
                return Array.from(document.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
            },

            /**
             * Create hidden images UI elements
             */
            createHiddenImagesUI() {
                const container = document.createElement('div');

                // Toggle button
                const toggleBtn = document.createElement('button');
                toggleBtn.id = 'toggle-hidden-mode';
                toggleBtn.setAttribute('aria-label', 'Toggle hidden images view');
                toggleBtn.setAttribute('aria-pressed', 'false');
                const showHiddenText = document.createElement('span');
                showHiddenText.className = 'show-hidden-text';
                showHiddenText.textContent = 'Show Hidden';
                const showGalleryText = document.createElement('span');
                showGalleryText.className = 'show-gallery-text';
                showGalleryText.style.display = 'none';
                showGalleryText.textContent = 'Back to Gallery';
                toggleBtn.appendChild(showHiddenText);
                toggleBtn.appendChild(showGalleryText);
                container.appendChild(toggleBtn);

                // Badge
                const badge = document.createElement('span');
                badge.className = 'hidden-count-badge';
                badge.style.display = 'none';
                container.appendChild(badge);

                // Unhide all button
                const unhideAllBtn = document.createElement('button');
                unhideAllBtn.id = 'unhide-all-button';
                unhideAllBtn.style.display = 'none';
                unhideAllBtn.setAttribute('aria-label', 'Unhide all hidden images');
                unhideAllBtn.textContent = 'Unhide All';
                container.appendChild(unhideAllBtn);

                // Modal hide button
                const modalHideBtn = document.createElement('button');
                modalHideBtn.id = 'modal-hide-button';
                modalHideBtn.className = 'modal-hide-button';
                modalHideBtn.setAttribute('aria-label', 'Hide this image from gallery');
                const hideText = document.createElement('span');
                hideText.id = 'modal-hide-text';
                hideText.textContent = 'Hide Image';
                modalHideBtn.appendChild(hideText);
                container.appendChild(modalHideBtn);

                // ARIA live region
                const ariaLive = document.createElement('div');
                ariaLive.id = 'aria-live-region';
                ariaLive.setAttribute('aria-live', 'polite');
                ariaLive.setAttribute('aria-atomic', 'true');
                ariaLive.className = 'sr-only';
                container.appendChild(ariaLive);

                return container;
            }
        };

        describe('Hidden Images Feature', function() {
            let fixtures;
            let containers;
            let statusBar;
            let exportButton;
            let modal;
            let hiddenUI;
            let mockStorage;

            // Mock global functions that would be in the actual gallery
            let hiddenImages = {};
            let isHiddenMode = false;
            let selectedImages = {};

            // Mock implementation of gallery functions
            function isImageHidden(imagePath) {
                return hiddenImages[imagePath] === true;
            }

            function hideImage(imagePath) {
                hiddenImages[imagePath] = true;
                // Clear only this image's selection
                const checkbox = document.querySelector(`[data-full-image="${imagePath}"] .select-checkbox`);
                if (checkbox && checkbox.checked) {
                    checkbox.checked = false;
                    checkbox.parentElement.classList.remove('selected');
                    delete selectedImages[imagePath];
                }
            }

            function unhideImage(imagePath) {
                delete hiddenImages[imagePath];
            }

            function getHiddenImagesCount() {
                return Object.keys(hiddenImages).filter(key => hiddenImages[key]).length;
            }

            function toggleHiddenMode() {
                isHiddenMode = !isHiddenMode;
                const toggleButton = document.getElementById('toggle-hidden-mode');
                const unhideAllButton = document.getElementById('unhide-all-button');
                const statusBarEl = document.getElementById('status-bar');
                const showHiddenText = toggleButton?.querySelector('.show-hidden-text');
                const showGalleryText = toggleButton?.querySelector('.show-gallery-text');

                if (isHiddenMode) {
                    toggleButton?.setAttribute('aria-pressed', 'true');
                    if (showHiddenText) showHiddenText.style.display = 'none';
                    if (showGalleryText) showGalleryText.style.display = 'inline';
                    if (unhideAllButton) unhideAllButton.style.display = 'inline-block';
                    if (statusBarEl) statusBarEl.classList.add('hidden-mode');
                } else {
                    toggleButton?.setAttribute('aria-pressed', 'false');
                    if (showHiddenText) showHiddenText.style.display = 'inline';
                    if (showGalleryText) showGalleryText.style.display = 'none';
                    if (unhideAllButton) unhideAllButton.style.display = 'none';
                    if (statusBarEl) statusBarEl.classList.remove('hidden-mode');
                }
            }

            function updateHiddenCountBadge() {
                const badge = document.querySelector('.hidden-count-badge');
                if (!badge) return;

                const count = getHiddenImagesCount();
                if (count > 0 && !isHiddenMode) {
                    badge.style.display = 'flex';
                    badge.textContent = count;
                    badge.setAttribute('aria-label', `${count} hidden images`);
                } else {
                    badge.style.display = 'none';
                }
            }

            function filterImages() {
                const imageContainers = document.querySelectorAll('.image-container');
                imageContainers.forEach(img => {
                    const imgPath = img.getAttribute('data-full-image');
                    let hiddenMatch = true;
                    if (isHiddenMode) {
                        hiddenMatch = isImageHidden(imgPath);
                    } else {
                        hiddenMatch = !isImageHidden(imgPath);
                    }
                    img.style.display = hiddenMatch ? 'flex' : 'none';
                });
            }

            function updateCounts() {
                const statusBarEl = document.getElementById('status-bar');
                if (!statusBarEl) return;

                const allContainers = document.querySelectorAll('.image-container');
                const totalImages = allContainers.length;
                const visibleCount = Array.from(allContainers).filter(c => c.style.display !== 'none').length;
                const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;

                let statusText = `Showing ${visibleCount} of ${totalImages} images | ${selectedCount} selected`;
                if (isHiddenMode) {
                    statusText += ' | HIDDEN IMAGES MODE';
                }
                statusBarEl.textContent = statusText;
            }

            function announceToScreenReader(message) {
                const liveRegion = document.getElementById('aria-live-region');
                if (liveRegion) {
                    liveRegion.textContent = message;
                }
            }

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                // Reset state
                hiddenImages = {};
                isHiddenMode = false;
                selectedImages = {};

                // Create gallery
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // Create UI elements
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);

                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                hiddenUI = HiddenImagesTestHelpers.createHiddenImagesUI();
                fixtures.appendChild(hiddenUI);

                // Mock localStorage
                mockStorage = TestHelpers.mockLocalStorage();
                window.localStorage = mockStorage;
            });

            afterEach(function() {
                TestHelpers.cleanup();
                HiddenImagesTestHelpers.clearHiddenImages();
            });

            describe('Core Functionality', function() {
                it('should hide single image', function() {
                    const imagePath = '/path/to/image_1.jpg';
                    hideImage(imagePath);

                    expect(isImageHidden(imagePath)).to.be.true;
                });

                it('should unhide single image', function() {
                    const imagePath = '/path/to/image_1.jpg';
                    hideImage(imagePath);
                    unhideImage(imagePath);

                    expect(isImageHidden(imagePath)).to.be.false;
                });

                it('should hide multiple images', function() {
                    const paths = ['/path/to/image_1.jpg', '/path/to/image_2.jpg', '/path/to/image_3.jpg'];
                    paths.forEach(path => hideImage(path));

                    paths.forEach(path => {
                        expect(isImageHidden(path)).to.be.true;
                    });
                });

                it('should get hidden images count correctly', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    expect(getHiddenImagesCount()).to.equal(2);
                });

                it('should return correct boolean from isImageHidden()', function() {
                    const path = '/path/to/image_1.jpg';

                    expect(isImageHidden(path)).to.be.false;

                    hideImage(path);
                    expect(isImageHidden(path)).to.be.true;

                    unhideImage(path);
                    expect(isImageHidden(path)).to.be.false;
                });

                it('should update in-memory cache immediately on hideImage()', function() {
                    const path = '/path/to/image_1.jpg';

                    hideImage(path);

                    // Check in-memory cache directly
                    expect(hiddenImages[path]).to.be.true;
                    expect(isImageHidden(path)).to.be.true;
                });

                it('should update in-memory cache immediately on unhideImage()', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    unhideImage(path);

                    // Check in-memory cache directly
                    expect(hiddenImages[path]).to.be.undefined;
                    expect(isImageHidden(path)).to.be.false;
                });

                it('should handle hiding same image twice without errors', function() {
                    const path = '/path/to/image_1.jpg';

                    hideImage(path);
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                    expect(getHiddenImagesCount()).to.equal(1);
                });

                it('should handle unhiding non-hidden image without errors', function() {
                    const path = '/path/to/image_1.jpg';

                    unhideImage(path);

                    expect(isImageHidden(path)).to.be.false;
                    expect(getHiddenImagesCount()).to.equal(0);
                });

                it('should handle image paths with special characters', function() {
                    const path = '/path/to/image with spaces & special-chars_123.jpg';
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                });
            });

            describe('localStorage Persistence', function() {
                it('should save hidden images with debounce delay', async function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    // Simulate debounced save
                    const storageKey = 'gallery_test_html_hidden';
                    await HiddenImagesTestHelpers.waitForSave();

                    mockStorage.setItem(storageKey, JSON.stringify(hiddenImages));

                    const saved = JSON.parse(mockStorage.getItem(storageKey));
                    expect(saved[path]).to.be.true;
                });

                it('should use gallery identifier in localStorage key', function() {
                    const storageKey = 'gallery_test_html_hidden';
                    mockStorage.setItem(storageKey, JSON.stringify({'/img1.jpg': true}));

                    const saved = mockStorage.getItem(storageKey);
                    expect(saved).to.not.be.null;
                    expect(saved).to.include('img1.jpg');
                });

                it('should restore hidden images on page load', function() {
                    const data = {
                        '/path/to/image_1.jpg': true,
                        '/path/to/image_3.jpg': true
                    };

                    mockStorage.setItem('gallery_test_html_hidden', JSON.stringify(data));

                    // Simulate restore
                    const savedData = mockStorage.getItem('gallery_test_html_hidden');
                    hiddenImages = savedData ? JSON.parse(savedData) : {};

                    expect(isImageHidden('/path/to/image_1.jpg')).to.be.true;
                    expect(isImageHidden('/path/to/image_3.jpg')).to.be.true;
                    expect(getHiddenImagesCount()).to.equal(2);
                });

                it('should handle localStorage errors gracefully', function() {
                    mockStorage.setItem.throws(new Error('QuotaExceededError'));

                    // Should not crash
                    try {
                        mockStorage.setItem('test', JSON.stringify(hiddenImages));
                    } catch (e) {
                        expect(e.message).to.equal('QuotaExceededError');
                    }
                });

                it('should return empty object when no hidden images', function() {
                    mockStorage.setItem('gallery_test_html_hidden', JSON.stringify({}));

                    const saved = JSON.parse(mockStorage.getItem('gallery_test_html_hidden'));
                    expect(Object.keys(saved).length).to.equal(0);
                });

                it('should use correct JSON format: {"/path": true}', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    const data = JSON.stringify(hiddenImages);
                    const parsed = JSON.parse(data);

                    expect(parsed[path]).to.equal(true);
                    expect(typeof parsed[path]).to.equal('boolean');
                });

                it('should batch multiple rapid hides to single save (debounce)', async function() {
                    let saveCount = 0;
                    const mockSave = sinon.stub().callsFake(() => saveCount++);

                    // Rapid hides
                    for (let i = 1; i <= 5; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }

                    // In real implementation, debounced save would be called once
                    // Here we simulate it
                    await HiddenImagesTestHelpers.waitForSave();
                    mockSave();

                    expect(saveCount).to.equal(1);
                    expect(getHiddenImagesCount()).to.equal(5);
                });

                it('should handle missing localStorage gracefully', function() {
                    const originalLS = window.localStorage;
                    delete window.localStorage;

                    // Should not crash
                    expect(window.localStorage).to.be.undefined;

                    window.localStorage = originalLS;
                });
            });

            describe('Modal Integration', function() {
                it('should have modal hide button in DOM', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn).to.exist;
                });

                it('should hide current image when H key pressed', function() {
                    const path = '/path/to/image_1.jpg';

                    // Simulate opening modal with image
                    modal.classList.add('show');

                    // Press H key - in real implementation this would call hideCurrentImage()
                    // Here we simulate the behavior
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                });

                it('should navigate to next image after hiding current', function() {
                    // Hide first image
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();

                    // First image should be hidden, second should be visible
                    expect(visibleImages.length).to.equal(9);
                    expect(visibleImages[0].getAttribute('data-full-image')).to.equal('/path/to/image_2.jpg');
                });

                it('should navigate to previous if hiding last image', function() {
                    // Hide all but last image
                    for (let i = 1; i <= 9; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(1);
                    expect(visibleImages[0].getAttribute('data-full-image')).to.equal('/path/to/image_10.jpg');
                });

                it('should close modal if hiding last remaining image', function() {
                    // Hide all but one
                    for (let i = 1; i <= 9; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }

                    modal.classList.add('show');
                    filterImages();

                    // Hide last image
                    hideImage('/path/to/image_10.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);

                    // Modal should close (simulate)
                    if (visibleImages.length === 0) {
                        modal.classList.remove('show');
                    }

                    expect(modal.classList.contains('show')).to.be.false;
                });

                it('should change button to green "Unhide" in hidden mode', function() {
                    toggleHiddenMode();

                    const hideBtn = document.getElementById('modal-hide-button');
                    const hideText = document.getElementById('modal-hide-text');

                    // Simulate updateModalHideButton()
                    if (isHiddenMode) {
                        hideBtn.classList.add('unhide-mode');
                        hideText.textContent = 'Unhide Image';
                    }

                    expect(hideBtn.classList.contains('unhide-mode')).to.be.true;
                    expect(hideText.textContent).to.equal('Unhide Image');
                });

                it('should show red "Hide" button in normal mode', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    const hideText = document.getElementById('modal-hide-text');

                    expect(hideBtn.classList.contains('unhide-mode')).to.be.false;
                    expect(hideText.textContent).to.equal('Hide Image');
                });

                it('should unhide current image in hidden mode', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);
                    toggleHiddenMode();

                    // Simulate unhiding
                    unhideImage(path);

                    expect(isImageHidden(path)).to.be.false;
                });

                it('should update visible images cache after hide', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    const paths = visibleImages.map(v => v.getAttribute('data-full-image'));

                    expect(paths).to.not.include('/path/to/image_1.jpg');
                    expect(visibleImages.length).to.equal(9);
                });

                it('should have proper aria-label on hide button', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn.getAttribute('aria-label')).to.equal('Hide this image from gallery');
                });

                it('should update aria-label when switching to unhide mode', function() {
                    toggleHiddenMode();
                    const hideBtn = document.getElementById('modal-hide-button');

                    // Simulate update
                    if (isHiddenMode) {
                        hideBtn.setAttribute('aria-label', 'Unhide this image and restore to gallery');
                    }

                    expect(hideBtn.getAttribute('aria-label')).to.equal('Unhide this image and restore to gallery');
                });
            });

            describe('Hidden Mode Toggle', function() {
                it('should toggle isHiddenMode boolean', function() {
                    expect(isHiddenMode).to.be.false;
                    toggleHiddenMode();
                    expect(isHiddenMode).to.be.true;
                    toggleHiddenMode();
                    expect(isHiddenMode).to.be.false;
                });

                it('should filter OUT hidden images in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(8);
                });

                it('should show ONLY hidden images in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(2);
                });

                it('should change toggle button text to "Back to Gallery"', function() {
                    toggleHiddenMode();

                    const showHiddenText = hiddenUI.querySelector('.show-hidden-text');
                    const showGalleryText = hiddenUI.querySelector('.show-gallery-text');

                    expect(showHiddenText.style.display).to.equal('none');
                    expect(showGalleryText.style.display).to.equal('inline');
                });

                it('should change toggle button text to "Show Hidden" in normal mode', function() {
                    const showHiddenText = hiddenUI.querySelector('.show-hidden-text');
                    const showGalleryText = hiddenUI.querySelector('.show-gallery-text');

                    expect(showHiddenText.style.display).to.not.equal('none');
                    expect(showGalleryText.style.display).to.equal('none');
                });

                it('should set aria-pressed to true in hidden mode', function() {
                    toggleHiddenMode();

                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.equal('true');
                });

                it('should set aria-pressed to false in normal mode', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.equal('false');
                });

                it('should show unhide all button only in hidden mode', function() {
                    const unhideAllBtn = document.getElementById('unhide-all-button');
                    expect(unhideAllBtn.style.display).to.equal('none');

                    toggleHiddenMode();
                    expect(unhideAllBtn.style.display).to.equal('inline-block');
                });

                it('should keep export button visible in hidden mode', function() {
                    toggleHiddenMode();

                    expect(exportButton.style.display).to.not.equal('none');
                });

                it('should show red background in status bar in hidden mode', function() {
                    toggleHiddenMode();

                    expect(statusBar.classList.contains('hidden-mode')).to.be.true;
                });

                it('should update status bar text in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();
                    updateCounts();

                    expect(statusBar.textContent).to.include('HIDDEN IMAGES MODE');
                });
            });

            describe('Unhide All', function() {
                it('should clear all hidden images on confirmation', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    hideImage('/path/to/image_3.jpg');

                    // Mock confirmation
                    const originalConfirm = window.confirm;
                    window.confirm = () => true;

                    // Simulate unhide all
                    hiddenImages = {};

                    expect(getHiddenImagesCount()).to.equal(0);

                    window.confirm = originalConfirm;
                });

                it('should not clear when confirmation cancelled', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    const originalConfirm = window.confirm;
                    window.confirm = () => false;

                    // Cancelled - don't clear
                    const countBefore = getHiddenImagesCount();

                    expect(countBefore).to.equal(2);

                    window.confirm = originalConfirm;
                });

                it('should auto-exit hidden mode after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();

                    const originalConfirm = window.confirm;
                    window.confirm = () => true;

                    // Simulate unhide all
                    hiddenImages = {};
                    if (isHiddenMode) {
                        toggleHiddenMode();
                    }

                    expect(isHiddenMode).to.be.false;

                    window.confirm = originalConfirm;
                });

                it('should show notification with count', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    const count = getHiddenImagesCount();
                    expect(count).to.equal(2);

                    // Notification would show: "All images restored (2 images)"
                });

                it('should update badge after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.not.equal('none');

                    // Unhide all
                    hiddenImages = {};
                    updateHiddenCountBadge();

                    expect(badge.style.display).to.equal('none');
                });

                it('should update status bar after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();
                    updateCounts();

                    let statusText = statusBar.textContent;
                    expect(statusText).to.include('Showing 9 of 10');

                    // Unhide all
                    hiddenImages = {};
                    filterImages();
                    updateCounts();

                    statusText = statusBar.textContent;
                    expect(statusText).to.include('Showing 10 of 10');
                });
            });

            describe('Selection Integration', function() {
                it('should clear ONLY that image\'s selection when hiding', function() {
                    // Select multiple images
                    containers[0].querySelector('.select-checkbox').checked = true;
                    containers[0].classList.add('selected');
                    selectedImages['/path/to/image_1.jpg'] = true;

                    containers[1].querySelector('.select-checkbox').checked = true;
                    containers[1].classList.add('selected');
                    selectedImages['/path/to/image_2.jpg'] = true;

                    // Hide only first image
                    hideImage('/path/to/image_1.jpg');

                    // First should be deselected, second still selected
                    expect(containers[0].querySelector('.select-checkbox').checked).to.be.false;
                    expect(containers[1].querySelector('.select-checkbox').checked).to.be.true;
                });

                it('should NOT restore selection when unhiding', function() {
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    selectedImages['/path/to/image_1.jpg'] = true;

                    hideImage('/path/to/image_1.jpg');
                    unhideImage('/path/to/image_1.jpg');

                    expect(checkbox.checked).to.be.false;
                });

                it('should exclude hidden images from selection count', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;
                    containers[1].querySelector('.select-checkbox').checked = true;

                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(1);
                });

                it('should allow export with selected images in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    // Select hidden image
                    containers[0].querySelector('.select-checkbox').checked = true;

                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(1);
                });

                it('should allow selection in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    expect(checkbox.checked).to.be.true;
                });

                it('should allow deselection in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    checkbox.checked = false;

                    expect(checkbox.checked).to.be.false;
                });

                it('should update export button badge when hiding selected image', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;
                    exportButton.classList.add('has-selection');
                    exportButton.querySelector('button').setAttribute('data-count', '1');

                    hideImage('/path/to/image_1.jpg');

                    // Badge should update to 0
                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(0);
                });
            });

            describe('Filtering Integration', function() {
                it('should respect orientation filters for hidden images', function() {
                    // Set some containers to portrait
                    containers[0].setAttribute('data-orientation', 'portrait');
                    containers[1].setAttribute('data-orientation', 'portrait');

                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    toggleHiddenMode();
                    filterImages();

                    // Both hidden images visible in hidden mode
                    expect(HiddenImagesTestHelpers.getVisibleImages().length).to.equal(2);
                });

                it('should respect focal length filters for hidden images', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(2);
                });

                it('should respect date filters for hidden images', function() {
                    hideImage('/path/to/image_1.jpg');

                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(1);
                });

                it('should always filter out hidden images in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    const paths = visibleImages.map(v => v.getAttribute('data-full-image'));

                    expect(paths).to.not.include('/path/to/image_1.jpg');
                });

                it('should invalidate visible images cache after hide', function() {
                    const visibleBefore = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleBefore.length).to.equal(10);

                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleAfter = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleAfter.length).to.equal(9);
                });

                it('should invalidate visible images cache after unhide', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleBefore = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleBefore.length).to.equal(9);

                    unhideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleAfter = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleAfter.length).to.equal(10);
                });

                it('should call filterImages after every hide', function() {
                    const spy = sinon.spy();

                    hideImage('/path/to/image_1.jpg');
                    spy();

                    expect(spy.calledOnce).to.be.true;
                });

                it('should call updateCounts after every hide', function() {
                    const spy = sinon.spy();

                    hideImage('/path/to/image_1.jpg');
                    spy();

                    expect(spy.calledOnce).to.be.true;
                });
            });

            describe('UI Updates', function() {
                it('should show badge count when hidden images exist', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('flex');
                    expect(badge.textContent).to.equal('2');
                });

                it('should hide badge when no hidden images', function() {
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('none');
                });

                it('should hide badge in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('none');
                });

                it('should show badge in normal mode with hidden images', function() {
                    hideImage('/path/to/image_1.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.not.equal('none');
                });

                it('should show hidden count in status bar in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    filterImages();
                    updateCounts();

                    // Status shows 8 visible out of 10 total (2 hidden)
                    expect(statusBar.textContent).to.include('Showing 8 of 10');
                });

                it('should show different format in status bar in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();
                    updateCounts();

                    expect(statusBar.textContent).to.include('HIDDEN IMAGES MODE');
                });

                it('should update badge with correct aria-label', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    hideImage('/path/to/image_3.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.getAttribute('aria-label')).to.equal('3 hidden images');
                });

                it('should announce hide action to screen reader', function() {
                    const message = 'Image hidden: test_image.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.equal(message);
                });

                it('should announce unhide action to screen reader', function() {
                    const message = 'Image restored: test_image.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.equal(message);
                });
            });

            describe('Edge Cases', function() {
                it('should handle hiding all images - gallery shows empty', function() {
                    containers.forEach(c => {
                        const path = c.getAttribute('data-full-image');
                        hideImage(path);
                    });
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);
                    expect(getHiddenImagesCount()).to.equal(10);
                });

                it('should auto-exit hidden mode when unhiding last hidden image', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();

                    unhideImage('/path/to/image_1.jpg');

                    // Simulate auto-exit
                    if (getHiddenImagesCount() === 0 && isHiddenMode) {
                        toggleHiddenMode();
                    }

                    expect(isHiddenMode).to.be.false;
                });

                it('should handle toggle mode with no hidden images', function() {
                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);
                });

                it('should call filterImages after every hide/unhide', function() {
                    let filterCalls = 0;

                    hideImage('/path/to/image_1.jpg');
                    filterCalls++;

                    unhideImage('/path/to/image_1.jpg');
                    filterCalls++;

                    expect(filterCalls).to.equal(2);
                });

                it('should call updateCounts after every hide/unhide', function() {
                    let updateCalls = 0;

                    hideImage('/path/to/image_1.jpg');
                    updateCalls++;

                    unhideImage('/path/to/image_1.jpg');
                    updateCalls++;

                    expect(updateCalls).to.equal(2);
                });

                it('should not read localStorage in hot path (use cache)', function() {
                    hideImage('/path/to/image_1.jpg');

                    // Multiple calls - should use in-memory cache
                    for (let i = 0; i < 100; i++) {
                        isImageHidden('/path/to/image_1.jpg');
                    }

                    // Only initial load and saves touch localStorage, not reads
                    expect(mockStorage.getItem.callCount).to.be.below(5);
                });

                it('should handle missing localStorage gracefully', function() {
                    const originalLS = window.localStorage;
                    delete window.localStorage;

                    // Should not crash
                    hideImage('/path/to/image_1.jpg');
                    expect(isImageHidden('/path/to/image_1.jpg')).to.be.true;

                    window.localStorage = originalLS;
                });
            });

            describe('Accessibility', function() {
                it('should have aria-label on modal hide button', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn.getAttribute('aria-label')).to.exist;
                });

                it('should have aria-label on toggle button', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-label')).to.equal('Toggle hidden images view');
                });

                it('should have aria-pressed on toggle button', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.exist;
                });

                it('should have aria-label on unhide all button', function() {
                    const unhideAllBtn = document.getElementById('unhide-all-button');
                    expect(unhideAllBtn.getAttribute('aria-label')).to.equal('Unhide all hidden images');
                });

                it('should have ARIA live region in DOM', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion).to.exist;
                    expect(liveRegion.getAttribute('aria-live')).to.equal('polite');
                });

                it('should update ARIA live region on announcements', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    const message = 'Test announcement';

                    announceToScreenReader(message);

                    expect(liveRegion.textContent).to.equal(message);
                });

                it('should announce when hiding image', function() {
                    const message = 'Image hidden: image_1.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.include('hidden');
                });

                it('should announce when unhiding image', function() {
                    const message = 'Image restored: image_1.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.include('restored');
                });

                it('should have aria-atomic on live region', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.getAttribute('aria-atomic')).to.equal('true');
                });
            });
        });

        // =============================================================================
        // RUN TESTS
        // =============================================================================

        // Run the tests
        mocha.run();
    </script>
</body>
</html>
