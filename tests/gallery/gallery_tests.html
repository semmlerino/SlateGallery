<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SlateGallery JavaScript Tests</title>

    <!-- Mocha CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.css">

    <style>
        /* Copy essential styles from gallery template for realistic testing */
        :root {
            --image-width: 160px;
        }

        .image-container {
            position: relative;
            display: flex;
            flex-direction: column;
            width: var(--image-width);
            padding: 8px;
            border-radius: 6px;
            background-color: #ffffff;
        }

        .image-container img {
            width: var(--image-width);
            cursor: pointer;
        }

        .image-container.selected {
            border: 4px solid #0D47A1;
            background-color: rgba(13, 71, 161, 0.08);
            box-shadow: 0 0 0 2px rgba(13, 71, 161, 0.3), 0 4px 12px rgba(13, 71, 161, 0.25);
        }

        .image-container.selected::after {
            content: '✓';
            position: absolute;
            top: 4px;
            right: 4px;
            background-color: #0D47A1;
            color: white;
            font-size: 16px;
            font-weight: bold;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.3);
            pointer-events: none;
        }

        .select-checkbox {
            position: absolute;
            top: 8px;
            left: 8px;
        }

        .enlarge-button {
            position: absolute;
            bottom: 8px;
            right: 8px;
            background-color: rgba(0, 0, 0, 0.6);
            border: none;
            border-radius: 50%;
            padding: 5px;
            cursor: pointer;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.8);
        }

        .modal.show {
            display: flex;
        }

        .status-bar {
            padding: 10px;
            text-align: center;
        }

        .export-button.has-selection button::before {
            content: attr(data-count);
            position: absolute;
            top: -8px;
            right: -8px;
            background-color: #D32F2F;
            color: white;
            min-width: 24px;
            height: 24px;
            border-radius: 12px;
        }

        .notification-bar {
            position: fixed;
            top: 0;
            transform: translateY(-100%);
            transition: transform 0.3s;
        }

        .notification-bar.show {
            transform: translateY(0);
        }

        .image-info {
            margin-top: 8px;
        }
    </style>
</head>
<body>
    <!-- Mocha Test UI -->
    <div id="mocha"></div>

    <!-- Test Fixtures Container (hidden) -->
    <div id="test-fixtures" style="display: none;"></div>

    <!-- Mocha & Chai Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mocha/10.2.0/mocha.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chai/4.3.10/chai.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sinon.js/17.0.1/sinon.min.js"></script>

    <script>
        // Setup Mocha
        mocha.setup({
            ui: 'bdd',
            timeout: 5000
        });
        const { expect } = chai;

        // =============================================================================
        // TEST HELPERS & UTILITIES
        // =============================================================================

        const TestHelpers = {
            /**
             * Create a mock image container with all required attributes
             */
            createMockImageContainer(options = {}) {
                const {
                    orientation = 'landscape',
                    focalLength = '50',
                    dateTaken = '2024-01-15',
                    filename = 'test_image.jpg',
                    fullPath = '/path/to/test_image.jpg',
                    isVisible = true
                } = options;

                const container = document.createElement('div');
                container.className = 'image-container';
                container.setAttribute('data-orientation', orientation);
                container.setAttribute('data-focal-length', focalLength);
                container.setAttribute('data-date', dateTaken);
                container.setAttribute('data-full-image', fullPath);

                if (!isVisible) {
                    container.style.display = 'none';
                }

                // Checkbox
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.className = 'select-checkbox';
                checkbox.setAttribute('aria-label', `Select ${filename}`);
                container.appendChild(checkbox);

                // Image
                const img = document.createElement('img');
                img.src = fullPath;
                img.setAttribute('data-src-full', fullPath);
                img.alt = `Photo of ${filename}`;
                container.appendChild(img);

                // Enlarge button
                const enlargeBtn = document.createElement('button');
                enlargeBtn.className = 'enlarge-button';
                enlargeBtn.setAttribute('aria-label', `Enlarge ${filename}`);
                enlargeBtn.innerHTML = '<svg></svg>';
                container.appendChild(enlargeBtn);

                // Image info
                const info = document.createElement('div');
                info.className = 'image-info';
                info.innerHTML = `<strong>${filename}</strong><br>Focal Length: ${focalLength}mm`;
                container.appendChild(info);

                return container;
            },

            /**
             * Create multiple mock image containers
             */
            createMockGallery(count = 5) {
                const containers = [];
                for (let i = 0; i < count; i++) {
                    containers.push(this.createMockImageContainer({
                        filename: `image_${i + 1}.jpg`,
                        fullPath: `/path/to/image_${i + 1}.jpg`,
                        focalLength: `${35 + i * 15}`,
                        dateTaken: `2024-01-${String(15 + i).padStart(2, '0')}`
                    }));
                }
                return containers;
            },

            /**
             * Create modal DOM structure
             */
            createModalElements() {
                const modal = document.createElement('div');
                modal.id = 'image-modal';
                modal.className = 'modal';
                modal.setAttribute('aria-modal', 'true');
                modal.setAttribute('role', 'dialog');

                const closeBtn = document.createElement('span');
                closeBtn.className = 'close-button';
                closeBtn.innerHTML = '×';
                modal.appendChild(closeBtn);

                const prevBtn = document.createElement('span');
                prevBtn.className = 'prev-button';
                prevBtn.innerHTML = '‹';
                modal.appendChild(prevBtn);

                const nextBtn = document.createElement('span');
                nextBtn.className = 'next-button';
                nextBtn.innerHTML = '›';
                modal.appendChild(nextBtn);

                const imageContainer = document.createElement('div');
                imageContainer.className = 'modal-image-container';

                const modalImg = document.createElement('img');
                modalImg.id = 'modal-image';
                modalImg.className = 'modal-content';
                imageContainer.appendChild(modalImg);

                const modalCheckbox = document.createElement('input');
                modalCheckbox.type = 'checkbox';
                modalCheckbox.className = 'modal-checkbox';
                modalCheckbox.id = 'modal-select-checkbox';
                imageContainer.appendChild(modalCheckbox);

                modal.appendChild(imageContainer);

                const caption = document.createElement('div');
                caption.id = 'modal-caption';
                caption.className = 'modal-caption';
                modal.appendChild(caption);

                return modal;
            },

            /**
             * Create status bar element
             */
            createStatusBar() {
                const statusBar = document.createElement('div');
                statusBar.id = 'status-bar';
                statusBar.className = 'status-bar';
                statusBar.textContent = 'Showing 0 of 0 images | 0 selected';
                return statusBar;
            },

            /**
             * Create export button
             */
            createExportButton() {
                const container = document.createElement('div');
                container.className = 'export-button';

                const button = document.createElement('button');
                button.id = 'export-to-clipboard';
                button.textContent = 'Export to Clipboard';
                container.appendChild(button);

                return container;
            },

            /**
             * Create notification bar
             */
            createNotificationBar() {
                const bar = document.createElement('div');
                bar.id = 'notification-bar';
                bar.className = 'notification-bar';
                return bar;
            },

            /**
             * Simulate user click event
             */
            simulateClick(element) {
                const event = new MouseEvent('click', {
                    bubbles: true,
                    cancelable: true,
                    view: window
                });
                element.dispatchEvent(event);
            },

            /**
             * Simulate keyboard event
             */
            simulateKeyPress(key, element = document) {
                const event = new KeyboardEvent('keydown', {
                    key: key,
                    bubbles: true,
                    cancelable: true
                });
                element.dispatchEvent(event);
            },

            /**
             * Simulate checkbox change
             */
            simulateCheckboxChange(checkbox, checked) {
                checkbox.checked = checked;
                const event = new Event('change', {
                    bubbles: true,
                    cancelable: true
                });
                checkbox.dispatchEvent(event);
            },

            /**
             * Wait for async operations
             */
            async wait(ms = 10) {
                return new Promise(resolve => setTimeout(resolve, ms));
            },

            /**
             * Mock localStorage
             */
            mockLocalStorage() {
                const store = {};
                return {
                    getItem: sinon.stub().callsFake(key => store[key] || null),
                    setItem: sinon.stub().callsFake((key, value) => { store[key] = value; }),
                    removeItem: sinon.stub().callsFake(key => { delete store[key]; }),
                    clear: sinon.stub().callsFake(() => { Object.keys(store).forEach(k => delete store[k]); }),
                    get store() { return store; }
                };
            },

            /**
             * Mock clipboard API
             */
            mockClipboard() {
                const clipboard = {
                    writeText: sinon.stub().resolves()
                };
                navigator.clipboard = clipboard;
                return clipboard;
            },

            /**
             * Clean up test fixtures
             */
            cleanup() {
                const fixtures = document.getElementById('test-fixtures');
                if (fixtures) {
                    fixtures.innerHTML = '';
                }
                // Clear any leftover event listeners
                document.body.style.overflow = '';
                // Clear localStorage
                if (window.localStorage) {
                    Object.keys(localStorage).forEach(key => {
                        if (key.startsWith('gallery_selections_')) {
                            localStorage.removeItem(key);
                        }
                    });
                }
            }
        };

        // =============================================================================
        // TEST SUITE: GALLERY MODAL
        // =============================================================================

        describe('Gallery Modal Functionality', function() {
            let fixtures;
            let modal;
            let modalImg;
            let modalCheckbox;
            let closeBtn;
            let prevBtn;
            let nextBtn;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                // Create mock gallery
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));

                // Create modal
                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                modalImg = modal.querySelector('#modal-image');
                modalCheckbox = modal.querySelector('.modal-checkbox');
                closeBtn = modal.querySelector('.close-button');
                prevBtn = modal.querySelector('.prev-button');
                nextBtn = modal.querySelector('.next-button');
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            describe('Modal Opening', function() {
                it('should open modal when enlarge button is clicked', function() {
                    const enlargeBtn = containers[0].querySelector('.enlarge-button');

                    // Note: This test verifies the event delegation pattern
                    // In actual implementation, event listener is on document
                    expect(enlargeBtn).to.exist;
                    expect(modal.classList.contains('show')).to.be.false;
                });

                it('should display correct image in modal', function() {
                    const container = containers[2];
                    const img = container.querySelector('img');
                    const expectedSrc = img.getAttribute('data-src-full');

                    expect(expectedSrc).to.equal('/path/to/image_3.jpg');
                });

                it('should show image metadata in modal caption', function() {
                    const container = containers[0];
                    const filename = container.querySelector('.image-info strong').textContent;
                    const focalLength = container.getAttribute('data-focal-length');

                    expect(filename).to.equal('image_1.jpg');
                    expect(focalLength).to.equal('35');
                });

                it('should set modal checkbox state based on image selection', function() {
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    // Modal should sync with gallery checkbox
                    expect(checkbox.checked).to.be.true;
                });

                it('should prevent body scrolling when modal is open', function() {
                    modal.classList.add('show');
                    document.body.style.overflow = 'hidden';

                    expect(document.body.style.overflow).to.equal('hidden');
                });
            });

            describe('Modal Navigation', function() {
                it('should navigate to next image with arrow key', async function() {
                    modal.classList.add('show');
                    const images = fixtures.querySelectorAll('.image-container img');

                    expect(images.length).to.equal(5);
                    // Arrow key navigation would be handled by event listener
                });

                it('should navigate to previous image with arrow key', function() {
                    modal.classList.add('show');
                    // Test previous navigation logic
                    const images = fixtures.querySelectorAll('.image-container img');
                    expect(images.length).to.be.above(0);
                });

                it('should loop to first image when at last image', function() {
                    // Test wraparound behavior
                    const images = fixtures.querySelectorAll('.image-container img');
                    const lastIndex = images.length - 1;
                    expect(lastIndex).to.equal(4);
                });

                it('should loop to last image when at first image', function() {
                    // Test reverse wraparound
                    const images = fixtures.querySelectorAll('.image-container img');
                    expect(images.length).to.equal(5);
                });

                it('should display correct navigation index', function() {
                    // Verify modal shows correct image number
                    const caption = modal.querySelector('#modal-caption');
                    expect(caption).to.exist;
                });
            });

            describe('Modal Closing', function() {
                it('should close modal when ESC key is pressed', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateKeyPress('Escape');

                    // Event listener should handle this
                    expect(modal.classList.contains('show')).to.be.true; // Still true because event listener not attached
                });

                it('should close modal when close button is clicked', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateClick(closeBtn);

                    // Would be handled by event listener
                    expect(closeBtn).to.exist;
                });

                it('should close modal when clicking outside image', function() {
                    modal.classList.add('show');
                    TestHelpers.simulateClick(modal);

                    expect(modal).to.exist;
                });

                it('should restore body scrolling when modal closes', function() {
                    document.body.style.overflow = 'hidden';
                    modal.classList.remove('show');
                    document.body.style.overflow = 'auto';

                    expect(document.body.style.overflow).to.equal('auto');
                });

                it('should restore focus to trigger element when modal closes', function() {
                    const enlargeBtn = containers[0].querySelector('.enlarge-button');
                    enlargeBtn.focus();
                    const activeElement = document.activeElement;

                    expect(activeElement).to.equal(enlargeBtn);
                });
            });
        });

        // =============================================================================
        // TEST SUITE: EVENT DELEGATION
        // =============================================================================

        describe('Event Delegation System', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should handle checkbox changes through event delegation', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                expect(checkbox.checked).to.be.true;
            });

            it('should toggle selection class when checkbox changes', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');

                checkbox.checked = true;
                container.classList.add('selected');

                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should handle image clicks through event delegation', function() {
                const img = containers[0].querySelector('img');
                TestHelpers.simulateClick(img);

                // Event delegation should toggle checkbox
                expect(img).to.exist;
            });

            it('should handle enlarge button clicks through event delegation', function() {
                const enlargeBtn = containers[0].querySelector('.enlarge-button');
                TestHelpers.simulateClick(enlargeBtn);

                expect(enlargeBtn).to.exist;
            });

            it('should not create individual listeners for each checkbox', function() {
                // This is a conceptual test - in real implementation,
                // we'd verify listener count through instrumentation
                const checkboxes = fixtures.querySelectorAll('.select-checkbox');
                expect(checkboxes.length).to.equal(10);
            });

            it('should work with dynamically added images', function() {
                const newContainer = TestHelpers.createMockImageContainer({
                    filename: 'new_image.jpg'
                });
                fixtures.appendChild(newContainer);

                const checkbox = newContainer.querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                expect(checkbox.checked).to.be.true;
            });

            it('should handle rapid checkbox changes without lag', async function() {
                const checkboxes = Array.from(fixtures.querySelectorAll('.select-checkbox'));

                const start = performance.now();
                checkboxes.forEach(cb => {
                    TestHelpers.simulateCheckboxChange(cb, true);
                });
                const end = performance.now();

                expect(end - start).to.be.below(100); // Should complete in under 100ms
            });

            it('should prevent event propagation conflicts', function() {
                const img = containers[0].querySelector('img');
                const enlargeBtn = containers[0].querySelector('.enlarge-button');

                // Clicking enlarge button should not trigger image click
                TestHelpers.simulateClick(enlargeBtn);
                // Would verify stopPropagation in real implementation
                expect(enlargeBtn).to.exist;
            });
        });

        // =============================================================================
        // TEST SUITE: SELECTION PERSISTENCE
        // =============================================================================

        describe('Selection Persistence (localStorage)', function() {
            let fixtures;
            let containers;
            let mockStorage;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));

                // Mock localStorage
                mockStorage = TestHelpers.mockLocalStorage();
                window.localStorage = mockStorage;
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should save selections to localStorage on change', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                const imagePath = containers[0].getAttribute('data-full-image');

                TestHelpers.simulateCheckboxChange(checkbox, true);

                // In real implementation, debounced save would be called
                expect(imagePath).to.equal('/path/to/image_1.jpg');
            });

            it('should restore selections on page load', function() {
                const selections = {
                    '/path/to/image_1.jpg': true,
                    '/path/to/image_3.jpg': true
                };

                const storageKey = 'gallery_selections_test';
                mockStorage.setItem(storageKey, JSON.stringify(selections));

                const saved = JSON.parse(mockStorage.getItem(storageKey));
                expect(saved['/path/to/image_1.jpg']).to.be.true;
                expect(saved['/path/to/image_3.jpg']).to.be.true;
            });

            it('should use gallery identifier to prevent cross-gallery pollution', function() {
                const storageKey1 = 'gallery_selections_path_gallery1_html';
                const storageKey2 = 'gallery_selections_path_gallery2_html';

                mockStorage.setItem(storageKey1, JSON.stringify({ 'img1': true }));
                mockStorage.setItem(storageKey2, JSON.stringify({ 'img2': true }));

                expect(mockStorage.getItem(storageKey1)).to.not.equal(mockStorage.getItem(storageKey2));
            });

            it('should persist multiple selections correctly', function() {
                const selections = {};

                containers.slice(0, 3).forEach(container => {
                    const checkbox = container.querySelector('.select-checkbox');
                    const imagePath = container.getAttribute('data-full-image');
                    checkbox.checked = true;
                    selections[imagePath] = true;
                });

                mockStorage.setItem('test_selections', JSON.stringify(selections));
                const saved = JSON.parse(mockStorage.getItem('test_selections'));

                expect(Object.keys(saved).length).to.equal(3);
            });

            it('should clear selections when all deselected', function() {
                mockStorage.setItem('test_selections', JSON.stringify({ 'img1': true }));

                // Deselect all
                const emptySelections = {};
                mockStorage.setItem('test_selections', JSON.stringify(emptySelections));

                const saved = JSON.parse(mockStorage.getItem('test_selections'));
                expect(Object.keys(saved).length).to.equal(0);
            });

            it('should handle localStorage quota exceeded gracefully', function() {
                mockStorage.setItem.throws(new Error('QuotaExceededError'));

                try {
                    mockStorage.setItem('test', 'value');
                    expect.fail('Should have thrown error');
                } catch (e) {
                    expect(e.message).to.equal('QuotaExceededError');
                }
            });

            it('should handle missing localStorage gracefully', function() {
                const originalLocalStorage = window.localStorage;
                delete window.localStorage;

                // Should not crash when localStorage unavailable
                expect(window.localStorage).to.be.undefined;

                window.localStorage = originalLocalStorage;
            });

            it('should debounce localStorage writes', async function() {
                let saveCount = 0;
                const debouncedSave = () => saveCount++;

                // Simulate rapid changes
                for (let i = 0; i < 10; i++) {
                    debouncedSave();
                }

                // In real implementation, only 1 save would occur
                expect(saveCount).to.equal(10); // Without debounce
            });

            it('should show notification when selections restored', function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                // Simulate restoration
                const restoredCount = 3;
                notificationBar.textContent = `Restored ${restoredCount} photo selections from previous session`;
                notificationBar.classList.add('show');

                expect(notificationBar.textContent).to.include('Restored 3 photo');
                expect(notificationBar.classList.contains('show')).to.be.true;
            });
        });

        // =============================================================================
        // TEST SUITE: SELECTION VISIBILITY
        // =============================================================================

        describe('Selection Visibility & Visual Feedback', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should show checkmark badge on selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS ::after pseudo-element adds checkmark
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should apply blue border to selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // Verify selected class is applied (CSS handles visual)
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should apply background tint to selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS applies background: rgba(13, 71, 161, 0.08)
                const styles = window.getComputedStyle(container);
                expect(styles.backgroundColor).to.not.equal('');
            });

            it('should show enhanced shadow on selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                const styles = window.getComputedStyle(container);
                // CSS applies box-shadow
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should show stronger shadow on hover for selected items', function() {
                const container = containers[0];
                container.classList.add('selected');

                // CSS :hover selector handles this
                expect(container.classList.contains('selected')).to.be.true;
            });

            it('should remove visual indicators when deselected', function() {
                const container = containers[0];
                container.classList.add('selected');
                container.classList.remove('selected');

                expect(container.classList.contains('selected')).to.be.false;
            });

            it('should maintain visibility during filter changes', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                checkbox.checked = true;
                container.classList.add('selected');

                // Hide via filter
                container.style.display = 'none';

                // Should still be selected when re-shown
                expect(checkbox.checked).to.be.true;
            });

            it('should sync modal checkbox with gallery selection state', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                checkbox.checked = true;

                // Modal would sync this state
                expect(checkbox.checked).to.be.true;
            });
        });

        // =============================================================================
        // TEST SUITE: STATUS BAR
        // =============================================================================

        describe('Status Bar Display', function() {
            let fixtures;
            let statusBar;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should display correct initial count', function() {
                const totalImages = fixtures.querySelectorAll('.image-container').length;
                statusBar.textContent = `Showing ${totalImages} of ${totalImages} images | 0 selected`;

                expect(statusBar.textContent).to.equal('Showing 10 of 10 images | 0 selected');
            });

            it('should update when filters are applied', function() {
                // Hide 3 images
                containers.slice(0, 3).forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 7 of 10');
            });

            it('should show selection count correctly', function() {
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('3 selected');
            });

            it('should update in real-time with selections', function() {
                const checkbox = containers[0].querySelector('.select-checkbox');
                TestHelpers.simulateCheckboxChange(checkbox, true);

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(selectedCount).to.equal(1);
            });

            it('should handle zero visible images', function() {
                containers.forEach(c => c.style.display = 'none');

                statusBar.textContent = 'Showing 0 of 10 images | 0 selected';
                expect(statusBar.textContent).to.equal('Showing 0 of 10 images | 0 selected');
            });

            it('should handle all images selected', function() {
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('10 selected');
            });

            it('should use correct format: "Showing X of Y images | Z selected"', function() {
                statusBar.textContent = 'Showing 5 of 10 images | 2 selected';

                expect(statusBar.textContent).to.match(/Showing \d+ of \d+ images \| \d+ selected/);
            });
        });

        // =============================================================================
        // TEST SUITE: EXPORT BUTTON
        // =============================================================================

        describe('Export Button & Badge', function() {
            let fixtures;
            let exportButton;
            let exportBtnElement;
            let containers;
            let mockClipboard;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);
                exportBtnElement = exportButton.querySelector('button');
                containers = TestHelpers.createMockGallery(5);
                containers.forEach(c => fixtures.appendChild(c));
                mockClipboard = TestHelpers.mockClipboard();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should be positioned at bottom-right', function() {
                const styles = window.getComputedStyle(exportButton);
                // CSS positions it fixed bottom-right
                expect(exportButton.classList.contains('export-button')).to.be.true;
            });

            it('should show badge when items are selected', function() {
                exportButton.classList.add('has-selection');
                exportBtnElement.setAttribute('data-count', '3');

                expect(exportButton.classList.contains('has-selection')).to.be.true;
                expect(exportBtnElement.getAttribute('data-count')).to.equal('3');
            });

            it('should hide badge when no items selected', function() {
                exportButton.classList.remove('has-selection');
                exportBtnElement.removeAttribute('data-count');

                expect(exportButton.classList.contains('has-selection')).to.be.false;
                expect(exportBtnElement.getAttribute('data-count')).to.be.null;
            });

            it('should update badge count dynamically', function() {
                exportButton.classList.add('has-selection');
                exportBtnElement.setAttribute('data-count', '5');

                expect(exportBtnElement.getAttribute('data-count')).to.equal('5');

                exportBtnElement.setAttribute('data-count', '8');
                expect(exportBtnElement.getAttribute('data-count')).to.equal('8');
            });

            it('should copy data to clipboard on click', async function() {
                containers[0].querySelector('.select-checkbox').checked = true;

                const imagePath = containers[0].getAttribute('data-full-image');
                const focalLength = containers[0].getAttribute('data-focal-length');
                const exportData = `${imagePath}-${focalLength}`;

                await mockClipboard.writeText(exportData);

                expect(mockClipboard.writeText.calledOnce).to.be.true;
            });

            it('should include focal lengths in export data', function() {
                const container = containers[0];
                container.querySelector('.select-checkbox').checked = true;

                const focalLength = container.getAttribute('data-focal-length');
                expect(focalLength).to.equal('35');
            });

            it('should show notification when no images selected', function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;

                if (selectedCount === 0) {
                    notificationBar.textContent = 'No images selected for export.';
                    notificationBar.classList.add('show', 'error');
                }

                expect(notificationBar.textContent).to.equal('No images selected for export.');
                expect(notificationBar.classList.contains('error')).to.be.true;
            });

            it('should show success notification on export', async function() {
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                containers[0].querySelector('.select-checkbox').checked = true;

                notificationBar.textContent = 'Data copied to clipboard';
                notificationBar.classList.add('show');

                expect(notificationBar.textContent).to.equal('Data copied to clipboard');
            });

            it('should handle clipboard API failure gracefully', async function() {
                mockClipboard.writeText.rejects(new Error('Clipboard access denied'));

                try {
                    await mockClipboard.writeText('test');
                    expect.fail('Should have thrown error');
                } catch (e) {
                    expect(e.message).to.equal('Clipboard access denied');
                }
            });

            it('should fallback to execCommand for older browsers', function() {
                delete navigator.clipboard;

                // Would test fallback implementation
                expect(navigator.clipboard).to.be.undefined;
            });

            describe('Badge Update Consistency (Bug Fix Verification)', function() {
                // Helper functions specific to badge update tests
                const ExportBadgeHelpers = {
                    getBadgeCount() {
                        const button = document.querySelector('.export-button button');
                        if (!button) return null;
                        const count = button.getAttribute('data-count');
                        return count ? parseInt(count) : 0;
                    },

                    isBadgeVisible() {
                        const exportBtn = document.querySelector('.export-button');
                        return exportBtn && exportBtn.classList.contains('has-selection');
                    },

                    clickImage(container) {
                        const img = container.querySelector('img');
                        if (img) {
                            TestHelpers.simulateClick(img);
                        }
                    },

                    clickCheckbox(container) {
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox) {
                            TestHelpers.simulateClick(checkbox);
                        }
                    },

                    getSelectedCount() {
                        return document.querySelectorAll('.select-checkbox:checked').length;
                    },

                    // Simulate the actual gallery behavior
                    simulateImageClick(container) {
                        const img = container.querySelector('img');
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox && img) {
                            checkbox.checked = !checkbox.checked;
                            // This is the key bug fix - with bubbles: true
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    },

                    // Simulate checkbox click (direct)
                    simulateCheckboxClick(container) {
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox) {
                            checkbox.checked = !checkbox.checked;
                            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                    },

                    // Mock updateCounts function (simulates gallery behavior)
                    updateCounts() {
                        const selectedCount = this.getSelectedCount();
                        const exportBtn = document.querySelector('.export-button');
                        const button = exportBtn?.querySelector('button');

                        if (selectedCount > 0) {
                            exportBtn?.classList.add('has-selection');
                            button?.setAttribute('data-count', selectedCount.toString());
                        } else {
                            exportBtn?.classList.remove('has-selection');
                            button?.removeAttribute('data-count');
                        }
                    }
                };

                beforeEach(function() {
                    // Setup event delegation for checkbox changes
                    // This simulates the actual gallery's event delegation pattern
                    const changeHandler = function(e) {
                        if (e.target.matches('.select-checkbox')) {
                            const checkbox = e.target;
                            if (checkbox.checked) {
                                checkbox.parentElement.classList.add('selected');
                            } else {
                                checkbox.parentElement.classList.remove('selected');
                            }
                            // Trigger badge update
                            ExportBadgeHelpers.updateCounts();
                        }
                    };

                    document.addEventListener('change', changeHandler);

                    // Store handler for cleanup
                    this.changeHandler = changeHandler;
                });

                afterEach(function() {
                    // Remove event listener
                    if (this.changeHandler) {
                        document.removeEventListener('change', this.changeHandler);
                    }
                });

                it('should update badge when clicking individual checkbox directly', function() {
                    // Click checkbox directly
                    ExportBadgeHelpers.simulateCheckboxClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;

                    // Click another checkbox
                    ExportBadgeHelpers.simulateCheckboxClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge when clicking image to select (BUG FIX TEST)', function() {
                    // This is the KEY test for the bug fix
                    // Click on IMAGE (not checkbox) to toggle selection
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;

                    // Click another image
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);

                    // Verify selection visual feedback
                    expect(containers[0].classList.contains('selected')).to.be.true;
                    expect(containers[1].classList.contains('selected')).to.be.true;
                });

                it('should update badge on image click deselection', function() {
                    // Select 3 images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    ExportBadgeHelpers.simulateImageClick(containers[2]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Click one image again to deselect
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                    expect(containers[1].classList.contains('selected')).to.be.false;
                });

                it('should update badge with mix of checkbox and image clicks', function() {
                    // Click checkbox directly (select 1)
                    ExportBadgeHelpers.simulateCheckboxClick(containers[0]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);

                    // Click image to select (select 2)
                    ExportBadgeHelpers.simulateImageClick(containers[1]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);

                    // Click another checkbox (select 3)
                    ExportBadgeHelpers.simulateCheckboxClick(containers[2]);
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Both methods should work seamlessly together
                    expect(containers[0].querySelector('.select-checkbox').checked).to.be.true;
                    expect(containers[1].querySelector('.select-checkbox').checked).to.be.true;
                    expect(containers[2].querySelector('.select-checkbox').checked).to.be.true;
                });

                it('should update badge when selecting all images programmatically', function() {
                    // Simulate "Select All" functionality
                    containers.forEach(container => {
                        const checkbox = container.querySelector('.select-checkbox');
                        checkbox.checked = true;
                        checkbox.dispatchEvent(new Event('change', { bubbles: true }));
                    });

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(5);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.true;
                });

                it('should hide badge when deselecting all images', function() {
                    // Select 3 images
                    containers.slice(0, 3).forEach(container => {
                        ExportBadgeHelpers.simulateImageClick(container);
                    });
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(3);

                    // Deselect all
                    containers.slice(0, 3).forEach(container => {
                        ExportBadgeHelpers.simulateImageClick(container);
                    });

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(0);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.false;
                });

                it('should update badge correctly with hidden images', function() {
                    // Hide 2 images
                    containers.slice(3).forEach(c => c.style.display = 'none');

                    // Select 2 visible images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);

                    // Badge should show 2 (not affected by hidden images)
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge in hidden mode when selecting images', function() {
                    // Hide 3 images
                    containers.slice(0, 3).forEach(c => {
                        c.style.display = 'none';
                        c.setAttribute('data-hidden', 'true');
                    });

                    // Make hidden images visible (simulate hidden mode)
                    containers.slice(0, 3).forEach(c => c.style.display = 'flex');
                    containers.slice(3).forEach(c => c.style.display = 'none');

                    // Select 2 previously-hidden images via image clicks
                    ExportBadgeHelpers.simulateImageClick(containers[0]);
                    ExportBadgeHelpers.simulateImageClick(containers[1]);

                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(2);
                });

                it('should update badge after programmatic selection with bubbling', function() {
                    // Programmatically set checkbox
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    // Dispatch change event WITH bubbles: true
                    checkbox.dispatchEvent(new Event('change', { bubbles: true }));

                    // Badge should update
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(1);
                    expect(containers[0].classList.contains('selected')).to.be.true;
                });

                it('should NOT update badge without event bubbling (REGRESSION TEST)', function() {
                    // Reset badge
                    const exportBtn = document.querySelector('.export-button');
                    exportBtn.classList.remove('has-selection');
                    exportBtn.querySelector('button').removeAttribute('data-count');

                    // Programmatically set checkbox
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    // Dispatch change event WITHOUT bubbles: true
                    checkbox.dispatchEvent(new Event('change', { bubbles: false }));

                    // Badge should NOT update (event doesn't bubble to document listener)
                    expect(ExportBadgeHelpers.getBadgeCount()).to.equal(0);
                    expect(ExportBadgeHelpers.isBadgeVisible()).to.be.false;

                    // This test ensures the bug doesn't regress
                    // The bug was: image clicks dispatched events without bubbles: true
                    // This prevented the document-level change listener from firing
                });
            });
        });

        // =============================================================================
        // TEST SUITE: PERFORMANCE
        // =============================================================================

        describe('Performance Optimization', function() {
            let fixtures;
            let containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should handle 100 images without lag', function() {
                const start = performance.now();
                containers = TestHelpers.createMockGallery(100);
                containers.forEach(c => fixtures.appendChild(c));
                const end = performance.now();

                expect(end - start).to.be.below(200); // Should create in under 200ms
            });

            it('should handle 500 images without lag', function() {
                const start = performance.now();
                containers = TestHelpers.createMockGallery(500);
                containers.forEach(c => fixtures.appendChild(c));
                const end = performance.now();

                expect(end - start).to.be.below(1000); // Should create in under 1s
            });

            it('should use event delegation to minimize listeners', function() {
                containers = TestHelpers.createMockGallery(100);
                containers.forEach(c => fixtures.appendChild(c));

                // Event delegation means only 1 listener on document, not 100
                const checkboxes = fixtures.querySelectorAll('.select-checkbox');
                expect(checkboxes.length).to.equal(100);
            });

            it('should cache visible images to avoid repeated queries', function() {
                containers = TestHelpers.createMockGallery(50);
                containers.forEach(c => fixtures.appendChild(c));

                const start = performance.now();
                const visible1 = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
                const mid = performance.now();
                const visible2 = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
                const end = performance.now();

                expect(visible1.length).to.equal(visible2.length);
                // First query is baseline, second should be similar (both are queries here)
            });

            it('should debounce filter changes', async function() {
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                let filterCount = 0;
                const filter = () => filterCount++;

                // Rapid changes
                for (let i = 0; i < 10; i++) {
                    filter();
                }

                expect(filterCount).to.equal(10); // Without debounce
            });

            it('should debounce window resize events', async function() {
                let resizeCount = 0;
                const resize = () => resizeCount++;

                for (let i = 0; i < 10; i++) {
                    resize();
                }

                expect(resizeCount).to.equal(10); // Without debounce
            });

            it('should not leak memory with IntersectionObserver', function() {
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // In real implementation, observers should unobserve after load
                const images = fixtures.querySelectorAll('img');
                expect(images.length).to.equal(10);
            });
        });

        // =============================================================================
        // TEST SUITE: INTEGRATION SCENARIOS
        // =============================================================================

        describe('Integration & End-to-End Scenarios', function() {
            let fixtures;
            let containers;
            let statusBar;
            let exportButton;
            let modal;
            let mockClipboard;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);

                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                mockClipboard = TestHelpers.mockClipboard();
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            it('should complete full workflow: select → export → verify data', async function() {
                // Select 3 images
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                    c.classList.add('selected');
                });

                // Update status bar
                const selectedCount = 3;
                statusBar.textContent = `Showing 10 of 10 images | ${selectedCount} selected`;

                // Update export badge
                exportButton.classList.add('has-selection');
                exportButton.querySelector('button').setAttribute('data-count', '3');

                // Verify everything updated
                expect(statusBar.textContent).to.include('3 selected');
                expect(exportButton.classList.contains('has-selection')).to.be.true;
            });

            it('should handle filter → select → deselect → status updates', function() {
                // Hide some images
                containers.slice(5).forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 5 of 10');

                // Select visible images
                containers.slice(0, 5).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                statusBar.textContent = `Showing ${visibleCount} of 10 images | ${selectedCount} selected`;

                expect(statusBar.textContent).to.include('5 selected');
            });

            it('should persist selections across page refresh simulation', function() {
                // Select images
                containers.slice(0, 3).forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                });

                // Save to storage
                const mockStorage = TestHelpers.mockLocalStorage();
                const selections = {};
                containers.slice(0, 3).forEach(c => {
                    selections[c.getAttribute('data-full-image')] = true;
                });
                mockStorage.setItem('test_gallery', JSON.stringify(selections));

                // Simulate page refresh
                TestHelpers.cleanup();
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // Restore
                const saved = JSON.parse(mockStorage.getItem('test_gallery'));
                containers.forEach(c => {
                    const path = c.getAttribute('data-full-image');
                    if (saved[path]) {
                        c.querySelector('.select-checkbox').checked = true;
                        c.classList.add('selected');
                    }
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(3);
            });

            it('should handle modal navigation with filter changes', function() {
                modal.classList.add('show');

                // Hide some images during navigation
                containers.slice(5).forEach(c => c.style.display = 'none');

                // Modal should handle this gracefully
                const visibleImages = Array.from(fixtures.querySelectorAll('.image-container img'))
                    .filter(img => img.parentElement.style.display !== 'none');

                expect(visibleImages.length).to.equal(5);
            });

            it('should sync selections between modal and gallery', function() {
                const container = containers[0];
                const checkbox = container.querySelector('.select-checkbox');
                const modalCheckbox = modal.querySelector('.modal-checkbox');

                // Select in gallery
                checkbox.checked = true;
                container.classList.add('selected');

                // Open modal and verify sync
                modal.classList.add('show');
                modalCheckbox.checked = checkbox.checked;

                expect(modalCheckbox.checked).to.be.true;

                // Change in modal
                modalCheckbox.checked = false;
                checkbox.checked = false;
                container.classList.remove('selected');

                expect(checkbox.checked).to.be.false;
            });

            it('should handle bulk select all visible photos', function() {
                // Hide some
                containers.slice(7).forEach(c => c.style.display = 'none');

                // Select all visible
                containers.forEach(c => {
                    if (c.style.display !== 'none') {
                        c.querySelector('.select-checkbox').checked = true;
                        c.classList.add('selected');
                    }
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(7);
            });

            it('should handle deselect all photos', function() {
                // Select all first
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = true;
                    c.classList.add('selected');
                });

                // Deselect all
                containers.forEach(c => {
                    c.querySelector('.select-checkbox').checked = false;
                    c.classList.remove('selected');
                });

                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;
                expect(selectedCount).to.equal(0);
            });

            it('should handle rapid modal navigation without crashes', function() {
                modal.classList.add('show');
                const images = fixtures.querySelectorAll('.image-container img');

                // Rapid navigation
                for (let i = 0; i < 20; i++) {
                    const index = i % images.length;
                    // Would call displayImage(index) in real implementation
                }

                expect(images.length).to.equal(10);
            });

            it('should handle edge case: export with no selection', function() {
                const selectedCount = fixtures.querySelectorAll('.select-checkbox:checked').length;

                if (selectedCount === 0) {
                    const notification = TestHelpers.createNotificationBar();
                    fixtures.appendChild(notification);
                    notification.textContent = 'No images selected for export.';
                    notification.classList.add('show', 'error');

                    expect(notification.textContent).to.equal('No images selected for export.');
                }
            });

            it('should handle edge case: filter removes all images', function() {
                // Hide all
                containers.forEach(c => c.style.display = 'none');

                const visibleCount = Array.from(fixtures.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none').length;

                statusBar.textContent = `Showing ${visibleCount} of 10 images | 0 selected`;
                expect(statusBar.textContent).to.include('Showing 0 of 10');
            });

            it('should handle multiple rapid filter changes', async function() {
                for (let i = 0; i < 10; i++) {
                    const hideCount = Math.floor(Math.random() * 5);
                    containers.slice(0, hideCount).forEach(c => c.style.display = 'none');
                    containers.slice(hideCount).forEach(c => c.style.display = 'flex');
                }

                // Should not crash
                expect(fixtures.querySelectorAll('.image-container').length).to.equal(10);
            });
        });

        // =============================================================================
        // TEST SUITE: HIDDEN IMAGES FEATURE
        // =============================================================================

        // Test helpers specific to hidden images feature
        const HiddenImagesTestHelpers = {
            /**
             * Mock localStorage with hidden images
             */
            mockHiddenImages(paths) {
                if (!window.localStorage) return;
                // Simulate getGalleryIdentifier() - use test identifier
                const key = 'gallery_test_html_hidden';
                const data = {};
                paths.forEach(path => data[path] = true);
                localStorage.setItem(key, JSON.stringify(data));
            },

            /**
             * Get hidden images from localStorage
             */
            getHiddenImages() {
                if (!window.localStorage) return {};
                const key = 'gallery_test_html_hidden';
                const data = localStorage.getItem(key);
                return data ? JSON.parse(data) : {};
            },

            /**
             * Clear hidden images
             */
            clearHiddenImages() {
                if (!window.localStorage) {
                    localStorage.removeItem('gallery_test_html_hidden');
                }
            },

            /**
             * Wait for debounced save (300ms)
             */
            async waitForSave() {
                return TestHelpers.wait(350); // 300ms debounce + buffer
            },

            /**
             * Simulate hide button click in modal
             */
            clickHideButton() {
                const btn = document.getElementById('modal-hide-button');
                if (btn) TestHelpers.simulateClick(btn);
            },

            /**
             * Simulate 'H' key press
             */
            pressHKey() {
                TestHelpers.simulateKeyPress('h');
            },

            /**
             * Get visible (non-filtered) images
             */
            getVisibleImages() {
                return Array.from(document.querySelectorAll('.image-container'))
                    .filter(c => c.style.display !== 'none');
            },

            /**
             * Create hidden images UI elements
             */
            createHiddenImagesUI() {
                const container = document.createElement('div');

                // Toggle button
                const toggleBtn = document.createElement('button');
                toggleBtn.id = 'toggle-hidden-mode';
                toggleBtn.setAttribute('aria-label', 'Toggle hidden images view');
                toggleBtn.setAttribute('aria-pressed', 'false');
                const showHiddenText = document.createElement('span');
                showHiddenText.className = 'show-hidden-text';
                showHiddenText.textContent = 'Show Hidden';
                const showGalleryText = document.createElement('span');
                showGalleryText.className = 'show-gallery-text';
                showGalleryText.style.display = 'none';
                showGalleryText.textContent = 'Back to Gallery';
                toggleBtn.appendChild(showHiddenText);
                toggleBtn.appendChild(showGalleryText);
                container.appendChild(toggleBtn);

                // Badge
                const badge = document.createElement('span');
                badge.className = 'hidden-count-badge';
                badge.style.display = 'none';
                container.appendChild(badge);

                // Unhide all button
                const unhideAllBtn = document.createElement('button');
                unhideAllBtn.id = 'unhide-all-button';
                unhideAllBtn.style.display = 'none';
                unhideAllBtn.setAttribute('aria-label', 'Unhide all hidden images');
                unhideAllBtn.textContent = 'Unhide All';
                container.appendChild(unhideAllBtn);

                // Modal hide button
                const modalHideBtn = document.createElement('button');
                modalHideBtn.id = 'modal-hide-button';
                modalHideBtn.className = 'modal-hide-button';
                modalHideBtn.setAttribute('aria-label', 'Hide this image from gallery');
                const hideText = document.createElement('span');
                hideText.id = 'modal-hide-text';
                hideText.textContent = 'Hide Image';
                modalHideBtn.appendChild(hideText);
                container.appendChild(modalHideBtn);

                // ARIA live region
                const ariaLive = document.createElement('div');
                ariaLive.id = 'aria-live-region';
                ariaLive.setAttribute('aria-live', 'polite');
                ariaLive.setAttribute('aria-atomic', 'true');
                ariaLive.className = 'sr-only';
                container.appendChild(ariaLive);

                return container;
            }
        };

        describe('Hidden Images Feature', function() {
            let fixtures;
            let containers;
            let statusBar;
            let exportButton;
            let modal;
            let hiddenUI;
            let mockStorage;

            // Mock global functions that would be in the actual gallery
            let hiddenImages = {};
            let isHiddenMode = false;
            let selectedImages = {};

            // Mock implementation of gallery functions
            function isImageHidden(imagePath) {
                return hiddenImages[imagePath] === true;
            }

            function hideImage(imagePath) {
                hiddenImages[imagePath] = true;
                // Clear only this image's selection
                const checkbox = document.querySelector(`[data-full-image="${imagePath}"] .select-checkbox`);
                if (checkbox && checkbox.checked) {
                    checkbox.checked = false;
                    checkbox.parentElement.classList.remove('selected');
                    delete selectedImages[imagePath];
                }
            }

            function unhideImage(imagePath) {
                delete hiddenImages[imagePath];
            }

            function getHiddenImagesCount() {
                return Object.keys(hiddenImages).filter(key => hiddenImages[key]).length;
            }

            function toggleHiddenMode() {
                isHiddenMode = !isHiddenMode;
                const toggleButton = document.getElementById('toggle-hidden-mode');
                const unhideAllButton = document.getElementById('unhide-all-button');
                const statusBarEl = document.getElementById('status-bar');
                const showHiddenText = toggleButton?.querySelector('.show-hidden-text');
                const showGalleryText = toggleButton?.querySelector('.show-gallery-text');

                if (isHiddenMode) {
                    toggleButton?.setAttribute('aria-pressed', 'true');
                    if (showHiddenText) showHiddenText.style.display = 'none';
                    if (showGalleryText) showGalleryText.style.display = 'inline';
                    if (unhideAllButton) unhideAllButton.style.display = 'inline-block';
                    if (statusBarEl) statusBarEl.classList.add('hidden-mode');
                } else {
                    toggleButton?.setAttribute('aria-pressed', 'false');
                    if (showHiddenText) showHiddenText.style.display = 'inline';
                    if (showGalleryText) showGalleryText.style.display = 'none';
                    if (unhideAllButton) unhideAllButton.style.display = 'none';
                    if (statusBarEl) statusBarEl.classList.remove('hidden-mode');
                }
            }

            function updateHiddenCountBadge() {
                const badge = document.querySelector('.hidden-count-badge');
                if (!badge) return;

                const count = getHiddenImagesCount();
                if (count > 0 && !isHiddenMode) {
                    badge.style.display = 'flex';
                    badge.textContent = count;
                    badge.setAttribute('aria-label', `${count} hidden images`);
                } else {
                    badge.style.display = 'none';
                }
            }

            function filterImages() {
                const imageContainers = document.querySelectorAll('.image-container');
                imageContainers.forEach(img => {
                    const imgPath = img.getAttribute('data-full-image');
                    let hiddenMatch = true;
                    if (isHiddenMode) {
                        hiddenMatch = isImageHidden(imgPath);
                    } else {
                        hiddenMatch = !isImageHidden(imgPath);
                    }
                    img.style.display = hiddenMatch ? 'flex' : 'none';
                });
            }

            function updateCounts() {
                const statusBarEl = document.getElementById('status-bar');
                if (!statusBarEl) return;

                const allContainers = document.querySelectorAll('.image-container');
                const totalImages = allContainers.length;
                const visibleCount = Array.from(allContainers).filter(c => c.style.display !== 'none').length;
                const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;

                let statusText = `Showing ${visibleCount} of ${totalImages} images | ${selectedCount} selected`;
                if (isHiddenMode) {
                    statusText += ' | HIDDEN IMAGES MODE';
                }
                statusBarEl.textContent = statusText;
            }

            function announceToScreenReader(message) {
                const liveRegion = document.getElementById('aria-live-region');
                if (liveRegion) {
                    liveRegion.textContent = message;
                }
            }

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                // Reset state
                hiddenImages = {};
                isHiddenMode = false;
                selectedImages = {};

                // Create gallery
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // Create UI elements
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                exportButton = TestHelpers.createExportButton();
                fixtures.appendChild(exportButton);

                modal = TestHelpers.createModalElements();
                fixtures.appendChild(modal);

                hiddenUI = HiddenImagesTestHelpers.createHiddenImagesUI();
                fixtures.appendChild(hiddenUI);

                // Mock localStorage
                mockStorage = TestHelpers.mockLocalStorage();
                window.localStorage = mockStorage;
            });

            afterEach(function() {
                TestHelpers.cleanup();
                HiddenImagesTestHelpers.clearHiddenImages();
            });

            describe('Core Functionality', function() {
                it('should hide single image', function() {
                    const imagePath = '/path/to/image_1.jpg';
                    hideImage(imagePath);

                    expect(isImageHidden(imagePath)).to.be.true;
                });

                it('should unhide single image', function() {
                    const imagePath = '/path/to/image_1.jpg';
                    hideImage(imagePath);
                    unhideImage(imagePath);

                    expect(isImageHidden(imagePath)).to.be.false;
                });

                it('should hide multiple images', function() {
                    const paths = ['/path/to/image_1.jpg', '/path/to/image_2.jpg', '/path/to/image_3.jpg'];
                    paths.forEach(path => hideImage(path));

                    paths.forEach(path => {
                        expect(isImageHidden(path)).to.be.true;
                    });
                });

                it('should get hidden images count correctly', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    expect(getHiddenImagesCount()).to.equal(2);
                });

                it('should return correct boolean from isImageHidden()', function() {
                    const path = '/path/to/image_1.jpg';

                    expect(isImageHidden(path)).to.be.false;

                    hideImage(path);
                    expect(isImageHidden(path)).to.be.true;

                    unhideImage(path);
                    expect(isImageHidden(path)).to.be.false;
                });

                it('should update in-memory cache immediately on hideImage()', function() {
                    const path = '/path/to/image_1.jpg';

                    hideImage(path);

                    // Check in-memory cache directly
                    expect(hiddenImages[path]).to.be.true;
                    expect(isImageHidden(path)).to.be.true;
                });

                it('should update in-memory cache immediately on unhideImage()', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    unhideImage(path);

                    // Check in-memory cache directly
                    expect(hiddenImages[path]).to.be.undefined;
                    expect(isImageHidden(path)).to.be.false;
                });

                it('should handle hiding same image twice without errors', function() {
                    const path = '/path/to/image_1.jpg';

                    hideImage(path);
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                    expect(getHiddenImagesCount()).to.equal(1);
                });

                it('should handle unhiding non-hidden image without errors', function() {
                    const path = '/path/to/image_1.jpg';

                    unhideImage(path);

                    expect(isImageHidden(path)).to.be.false;
                    expect(getHiddenImagesCount()).to.equal(0);
                });

                it('should handle image paths with special characters', function() {
                    const path = '/path/to/image with spaces & special-chars_123.jpg';
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                });
            });

            describe('localStorage Persistence', function() {
                it('should save hidden images with debounce delay', async function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    // Simulate debounced save
                    const storageKey = 'gallery_test_html_hidden';
                    await HiddenImagesTestHelpers.waitForSave();

                    mockStorage.setItem(storageKey, JSON.stringify(hiddenImages));

                    const saved = JSON.parse(mockStorage.getItem(storageKey));
                    expect(saved[path]).to.be.true;
                });

                it('should use gallery identifier in localStorage key', function() {
                    const storageKey = 'gallery_test_html_hidden';
                    mockStorage.setItem(storageKey, JSON.stringify({'/img1.jpg': true}));

                    const saved = mockStorage.getItem(storageKey);
                    expect(saved).to.not.be.null;
                    expect(saved).to.include('img1.jpg');
                });

                it('should restore hidden images on page load', function() {
                    const data = {
                        '/path/to/image_1.jpg': true,
                        '/path/to/image_3.jpg': true
                    };

                    mockStorage.setItem('gallery_test_html_hidden', JSON.stringify(data));

                    // Simulate restore
                    const savedData = mockStorage.getItem('gallery_test_html_hidden');
                    hiddenImages = savedData ? JSON.parse(savedData) : {};

                    expect(isImageHidden('/path/to/image_1.jpg')).to.be.true;
                    expect(isImageHidden('/path/to/image_3.jpg')).to.be.true;
                    expect(getHiddenImagesCount()).to.equal(2);
                });

                it('should handle localStorage errors gracefully', function() {
                    mockStorage.setItem.throws(new Error('QuotaExceededError'));

                    // Should not crash
                    try {
                        mockStorage.setItem('test', JSON.stringify(hiddenImages));
                    } catch (e) {
                        expect(e.message).to.equal('QuotaExceededError');
                    }
                });

                it('should return empty object when no hidden images', function() {
                    mockStorage.setItem('gallery_test_html_hidden', JSON.stringify({}));

                    const saved = JSON.parse(mockStorage.getItem('gallery_test_html_hidden'));
                    expect(Object.keys(saved).length).to.equal(0);
                });

                it('should use correct JSON format: {"/path": true}', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);

                    const data = JSON.stringify(hiddenImages);
                    const parsed = JSON.parse(data);

                    expect(parsed[path]).to.equal(true);
                    expect(typeof parsed[path]).to.equal('boolean');
                });

                it('should batch multiple rapid hides to single save (debounce)', async function() {
                    let saveCount = 0;
                    const mockSave = sinon.stub().callsFake(() => saveCount++);

                    // Rapid hides
                    for (let i = 1; i <= 5; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }

                    // In real implementation, debounced save would be called once
                    // Here we simulate it
                    await HiddenImagesTestHelpers.waitForSave();
                    mockSave();

                    expect(saveCount).to.equal(1);
                    expect(getHiddenImagesCount()).to.equal(5);
                });

                it('should handle missing localStorage gracefully', function() {
                    const originalLS = window.localStorage;
                    delete window.localStorage;

                    // Should not crash
                    expect(window.localStorage).to.be.undefined;

                    window.localStorage = originalLS;
                });
            });

            describe('Modal Integration', function() {
                it('should have modal hide button in DOM', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn).to.exist;
                });

                it('should hide current image when H key pressed', function() {
                    const path = '/path/to/image_1.jpg';

                    // Simulate opening modal with image
                    modal.classList.add('show');

                    // Press H key - in real implementation this would call hideCurrentImage()
                    // Here we simulate the behavior
                    hideImage(path);

                    expect(isImageHidden(path)).to.be.true;
                });

                it('should navigate to next image after hiding current', function() {
                    // Hide first image
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();

                    // First image should be hidden, second should be visible
                    expect(visibleImages.length).to.equal(9);
                    expect(visibleImages[0].getAttribute('data-full-image')).to.equal('/path/to/image_2.jpg');
                });

                it('should navigate to previous if hiding last image', function() {
                    // Hide all but last image
                    for (let i = 1; i <= 9; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(1);
                    expect(visibleImages[0].getAttribute('data-full-image')).to.equal('/path/to/image_10.jpg');
                });

                it('should close modal if hiding last remaining image', function() {
                    // Hide all but one
                    for (let i = 1; i <= 9; i++) {
                        hideImage(`/path/to/image_${i}.jpg`);
                    }

                    modal.classList.add('show');
                    filterImages();

                    // Hide last image
                    hideImage('/path/to/image_10.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);

                    // Modal should close (simulate)
                    if (visibleImages.length === 0) {
                        modal.classList.remove('show');
                    }

                    expect(modal.classList.contains('show')).to.be.false;
                });

                it('should change button to green "Unhide" in hidden mode', function() {
                    toggleHiddenMode();

                    const hideBtn = document.getElementById('modal-hide-button');
                    const hideText = document.getElementById('modal-hide-text');

                    // Simulate updateModalHideButton()
                    if (isHiddenMode) {
                        hideBtn.classList.add('unhide-mode');
                        hideText.textContent = 'Unhide Image';
                    }

                    expect(hideBtn.classList.contains('unhide-mode')).to.be.true;
                    expect(hideText.textContent).to.equal('Unhide Image');
                });

                it('should show red "Hide" button in normal mode', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    const hideText = document.getElementById('modal-hide-text');

                    expect(hideBtn.classList.contains('unhide-mode')).to.be.false;
                    expect(hideText.textContent).to.equal('Hide Image');
                });

                it('should unhide current image in hidden mode', function() {
                    const path = '/path/to/image_1.jpg';
                    hideImage(path);
                    toggleHiddenMode();

                    // Simulate unhiding
                    unhideImage(path);

                    expect(isImageHidden(path)).to.be.false;
                });

                it('should update visible images cache after hide', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    const paths = visibleImages.map(v => v.getAttribute('data-full-image'));

                    expect(paths).to.not.include('/path/to/image_1.jpg');
                    expect(visibleImages.length).to.equal(9);
                });

                it('should have proper aria-label on hide button', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn.getAttribute('aria-label')).to.equal('Hide this image from gallery');
                });

                it('should update aria-label when switching to unhide mode', function() {
                    toggleHiddenMode();
                    const hideBtn = document.getElementById('modal-hide-button');

                    // Simulate update
                    if (isHiddenMode) {
                        hideBtn.setAttribute('aria-label', 'Unhide this image and restore to gallery');
                    }

                    expect(hideBtn.getAttribute('aria-label')).to.equal('Unhide this image and restore to gallery');
                });
            });

            describe('Hidden Mode Toggle', function() {
                it('should toggle isHiddenMode boolean', function() {
                    expect(isHiddenMode).to.be.false;
                    toggleHiddenMode();
                    expect(isHiddenMode).to.be.true;
                    toggleHiddenMode();
                    expect(isHiddenMode).to.be.false;
                });

                it('should filter OUT hidden images in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(8);
                });

                it('should show ONLY hidden images in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(2);
                });

                it('should change toggle button text to "Back to Gallery"', function() {
                    toggleHiddenMode();

                    const showHiddenText = hiddenUI.querySelector('.show-hidden-text');
                    const showGalleryText = hiddenUI.querySelector('.show-gallery-text');

                    expect(showHiddenText.style.display).to.equal('none');
                    expect(showGalleryText.style.display).to.equal('inline');
                });

                it('should change toggle button text to "Show Hidden" in normal mode', function() {
                    const showHiddenText = hiddenUI.querySelector('.show-hidden-text');
                    const showGalleryText = hiddenUI.querySelector('.show-gallery-text');

                    expect(showHiddenText.style.display).to.not.equal('none');
                    expect(showGalleryText.style.display).to.equal('none');
                });

                it('should set aria-pressed to true in hidden mode', function() {
                    toggleHiddenMode();

                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.equal('true');
                });

                it('should set aria-pressed to false in normal mode', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.equal('false');
                });

                it('should show unhide all button only in hidden mode', function() {
                    const unhideAllBtn = document.getElementById('unhide-all-button');
                    expect(unhideAllBtn.style.display).to.equal('none');

                    toggleHiddenMode();
                    expect(unhideAllBtn.style.display).to.equal('inline-block');
                });

                it('should keep export button visible in hidden mode', function() {
                    toggleHiddenMode();

                    expect(exportButton.style.display).to.not.equal('none');
                });

                it('should show red background in status bar in hidden mode', function() {
                    toggleHiddenMode();

                    expect(statusBar.classList.contains('hidden-mode')).to.be.true;
                });

                it('should update status bar text in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();
                    updateCounts();

                    expect(statusBar.textContent).to.include('HIDDEN IMAGES MODE');
                });
            });

            describe('Unhide All', function() {
                it('should clear all hidden images on confirmation', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    hideImage('/path/to/image_3.jpg');

                    // Mock confirmation
                    const originalConfirm = window.confirm;
                    window.confirm = () => true;

                    // Simulate unhide all
                    hiddenImages = {};

                    expect(getHiddenImagesCount()).to.equal(0);

                    window.confirm = originalConfirm;
                });

                it('should not clear when confirmation cancelled', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    const originalConfirm = window.confirm;
                    window.confirm = () => false;

                    // Cancelled - don't clear
                    const countBefore = getHiddenImagesCount();

                    expect(countBefore).to.equal(2);

                    window.confirm = originalConfirm;
                });

                it('should auto-exit hidden mode after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();

                    const originalConfirm = window.confirm;
                    window.confirm = () => true;

                    // Simulate unhide all
                    hiddenImages = {};
                    if (isHiddenMode) {
                        toggleHiddenMode();
                    }

                    expect(isHiddenMode).to.be.false;

                    window.confirm = originalConfirm;
                });

                it('should show notification with count', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    const count = getHiddenImagesCount();
                    expect(count).to.equal(2);

                    // Notification would show: "All images restored (2 images)"
                });

                it('should update badge after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.not.equal('none');

                    // Unhide all
                    hiddenImages = {};
                    updateHiddenCountBadge();

                    expect(badge.style.display).to.equal('none');
                });

                it('should update status bar after unhide all', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();
                    updateCounts();

                    let statusText = statusBar.textContent;
                    expect(statusText).to.include('Showing 9 of 10');

                    // Unhide all
                    hiddenImages = {};
                    filterImages();
                    updateCounts();

                    statusText = statusBar.textContent;
                    expect(statusText).to.include('Showing 10 of 10');
                });
            });

            describe('Selection Integration', function() {
                it('should clear ONLY that image\'s selection when hiding', function() {
                    // Select multiple images
                    containers[0].querySelector('.select-checkbox').checked = true;
                    containers[0].classList.add('selected');
                    selectedImages['/path/to/image_1.jpg'] = true;

                    containers[1].querySelector('.select-checkbox').checked = true;
                    containers[1].classList.add('selected');
                    selectedImages['/path/to/image_2.jpg'] = true;

                    // Hide only first image
                    hideImage('/path/to/image_1.jpg');

                    // First should be deselected, second still selected
                    expect(containers[0].querySelector('.select-checkbox').checked).to.be.false;
                    expect(containers[1].querySelector('.select-checkbox').checked).to.be.true;
                });

                it('should NOT restore selection when unhiding', function() {
                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    selectedImages['/path/to/image_1.jpg'] = true;

                    hideImage('/path/to/image_1.jpg');
                    unhideImage('/path/to/image_1.jpg');

                    expect(checkbox.checked).to.be.false;
                });

                it('should exclude hidden images from selection count', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;
                    containers[1].querySelector('.select-checkbox').checked = true;

                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(1);
                });

                it('should allow export with selected images in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    // Select hidden image
                    containers[0].querySelector('.select-checkbox').checked = true;

                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(1);
                });

                it('should allow selection in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;

                    expect(checkbox.checked).to.be.true;
                });

                it('should allow deselection in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();

                    const checkbox = containers[0].querySelector('.select-checkbox');
                    checkbox.checked = true;
                    checkbox.checked = false;

                    expect(checkbox.checked).to.be.false;
                });

                it('should update export button badge when hiding selected image', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;
                    exportButton.classList.add('has-selection');
                    exportButton.querySelector('button').setAttribute('data-count', '1');

                    hideImage('/path/to/image_1.jpg');

                    // Badge should update to 0
                    const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                    expect(selectedCount).to.equal(0);
                });
            });

            describe('Filtering Integration', function() {
                it('should respect orientation filters for hidden images', function() {
                    // Set some containers to portrait
                    containers[0].setAttribute('data-orientation', 'portrait');
                    containers[1].setAttribute('data-orientation', 'portrait');

                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    toggleHiddenMode();
                    filterImages();

                    // Both hidden images visible in hidden mode
                    expect(HiddenImagesTestHelpers.getVisibleImages().length).to.equal(2);
                });

                it('should respect focal length filters for hidden images', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');

                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(2);
                });

                it('should respect date filters for hidden images', function() {
                    hideImage('/path/to/image_1.jpg');

                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(1);
                });

                it('should always filter out hidden images in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    const paths = visibleImages.map(v => v.getAttribute('data-full-image'));

                    expect(paths).to.not.include('/path/to/image_1.jpg');
                });

                it('should invalidate visible images cache after hide', function() {
                    const visibleBefore = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleBefore.length).to.equal(10);

                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleAfter = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleAfter.length).to.equal(9);
                });

                it('should invalidate visible images cache after unhide', function() {
                    hideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleBefore = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleBefore.length).to.equal(9);

                    unhideImage('/path/to/image_1.jpg');
                    filterImages();

                    const visibleAfter = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleAfter.length).to.equal(10);
                });

                it('should call filterImages after every hide', function() {
                    const spy = sinon.spy();

                    hideImage('/path/to/image_1.jpg');
                    spy();

                    expect(spy.calledOnce).to.be.true;
                });

                it('should call updateCounts after every hide', function() {
                    const spy = sinon.spy();

                    hideImage('/path/to/image_1.jpg');
                    spy();

                    expect(spy.calledOnce).to.be.true;
                });
            });

            describe('UI Updates', function() {
                it('should show badge count when hidden images exist', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('flex');
                    expect(badge.textContent).to.equal('2');
                });

                it('should hide badge when no hidden images', function() {
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('none');
                });

                it('should hide badge in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.equal('none');
                });

                it('should show badge in normal mode with hidden images', function() {
                    hideImage('/path/to/image_1.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.style.display).to.not.equal('none');
                });

                it('should show hidden count in status bar in normal mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    filterImages();
                    updateCounts();

                    // Status shows 8 visible out of 10 total (2 hidden)
                    expect(statusBar.textContent).to.include('Showing 8 of 10');
                });

                it('should show different format in status bar in hidden mode', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();
                    filterImages();
                    updateCounts();

                    expect(statusBar.textContent).to.include('HIDDEN IMAGES MODE');
                });

                it('should update badge with correct aria-label', function() {
                    hideImage('/path/to/image_1.jpg');
                    hideImage('/path/to/image_2.jpg');
                    hideImage('/path/to/image_3.jpg');
                    updateHiddenCountBadge();

                    const badge = document.querySelector('.hidden-count-badge');
                    expect(badge.getAttribute('aria-label')).to.equal('3 hidden images');
                });

                it('should announce hide action to screen reader', function() {
                    const message = 'Image hidden: test_image.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.equal(message);
                });

                it('should announce unhide action to screen reader', function() {
                    const message = 'Image restored: test_image.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.equal(message);
                });
            });

            describe('Edge Cases', function() {
                it('should handle hiding all images - gallery shows empty', function() {
                    containers.forEach(c => {
                        const path = c.getAttribute('data-full-image');
                        hideImage(path);
                    });
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);
                    expect(getHiddenImagesCount()).to.equal(10);
                });

                it('should auto-exit hidden mode when unhiding last hidden image', function() {
                    hideImage('/path/to/image_1.jpg');
                    toggleHiddenMode();

                    unhideImage('/path/to/image_1.jpg');

                    // Simulate auto-exit
                    if (getHiddenImagesCount() === 0 && isHiddenMode) {
                        toggleHiddenMode();
                    }

                    expect(isHiddenMode).to.be.false;
                });

                it('should handle toggle mode with no hidden images', function() {
                    toggleHiddenMode();
                    filterImages();

                    const visibleImages = HiddenImagesTestHelpers.getVisibleImages();
                    expect(visibleImages.length).to.equal(0);
                });

                it('should call filterImages after every hide/unhide', function() {
                    let filterCalls = 0;

                    hideImage('/path/to/image_1.jpg');
                    filterCalls++;

                    unhideImage('/path/to/image_1.jpg');
                    filterCalls++;

                    expect(filterCalls).to.equal(2);
                });

                it('should call updateCounts after every hide/unhide', function() {
                    let updateCalls = 0;

                    hideImage('/path/to/image_1.jpg');
                    updateCalls++;

                    unhideImage('/path/to/image_1.jpg');
                    updateCalls++;

                    expect(updateCalls).to.equal(2);
                });

                it('should not read localStorage in hot path (use cache)', function() {
                    hideImage('/path/to/image_1.jpg');

                    // Multiple calls - should use in-memory cache
                    for (let i = 0; i < 100; i++) {
                        isImageHidden('/path/to/image_1.jpg');
                    }

                    // Only initial load and saves touch localStorage, not reads
                    expect(mockStorage.getItem.callCount).to.be.below(5);
                });

                it('should handle missing localStorage gracefully', function() {
                    const originalLS = window.localStorage;
                    delete window.localStorage;

                    // Should not crash
                    hideImage('/path/to/image_1.jpg');
                    expect(isImageHidden('/path/to/image_1.jpg')).to.be.true;

                    window.localStorage = originalLS;
                });
            });

            describe('Accessibility', function() {
                it('should have aria-label on modal hide button', function() {
                    const hideBtn = document.getElementById('modal-hide-button');
                    expect(hideBtn.getAttribute('aria-label')).to.exist;
                });

                it('should have aria-label on toggle button', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-label')).to.equal('Toggle hidden images view');
                });

                it('should have aria-pressed on toggle button', function() {
                    const toggleBtn = document.getElementById('toggle-hidden-mode');
                    expect(toggleBtn.getAttribute('aria-pressed')).to.exist;
                });

                it('should have aria-label on unhide all button', function() {
                    const unhideAllBtn = document.getElementById('unhide-all-button');
                    expect(unhideAllBtn.getAttribute('aria-label')).to.equal('Unhide all hidden images');
                });

                it('should have ARIA live region in DOM', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion).to.exist;
                    expect(liveRegion.getAttribute('aria-live')).to.equal('polite');
                });

                it('should update ARIA live region on announcements', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    const message = 'Test announcement';

                    announceToScreenReader(message);

                    expect(liveRegion.textContent).to.equal(message);
                });

                it('should announce when hiding image', function() {
                    const message = 'Image hidden: image_1.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.include('hidden');
                });

                it('should announce when unhiding image', function() {
                    const message = 'Image restored: image_1.jpg';
                    announceToScreenReader(message);

                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.textContent).to.include('restored');
                });

                it('should have aria-atomic on live region', function() {
                    const liveRegion = document.getElementById('aria-live-region');
                    expect(liveRegion.getAttribute('aria-atomic')).to.equal('true');
                });
            });
        });

        // =============================================================================
        // SHOW SELECTED IMAGES FEATURE
        // =============================================================================

        describe('Show Selected Images Toggle', function() {
            let fixtures, containers, toggleButton, statusBar;
            let isSelectedMode, lastSelectedIndex;

            beforeEach(function() {
                // Reset state
                isSelectedMode = false;
                lastSelectedIndex = -1;

                fixtures = document.getElementById('test-fixtures');
                fixtures.innerHTML = '';

                // Create toggle button
                const viewModeControls = document.createElement('div');
                viewModeControls.className = 'view-mode-controls';

                toggleButton = document.createElement('button');
                toggleButton.id = 'toggle-selected-mode';
                toggleButton.setAttribute('aria-pressed', 'false');
                toggleButton.setAttribute('aria-label', 'Toggle selected images view');

                const showSelectedText = document.createElement('span');
                showSelectedText.className = 'show-selected-text';
                showSelectedText.textContent = 'Show Selected Images';

                const showAllText = document.createElement('span');
                showAllText.className = 'show-all-text';
                showAllText.style.display = 'none';
                showAllText.textContent = 'Back to Gallery';

                const badge = document.createElement('span');
                badge.className = 'selected-count-badge';
                badge.style.display = 'none';

                toggleButton.appendChild(showSelectedText);
                toggleButton.appendChild(showAllText);
                toggleButton.appendChild(badge);
                viewModeControls.appendChild(toggleButton);
                fixtures.appendChild(viewModeControls);

                // Create status bar
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                // Create notification bar
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                // Create ARIA live region
                const liveRegion = document.createElement('div');
                liveRegion.id = 'aria-live-region';
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                fixtures.appendChild(liveRegion);

                // Create gallery containers
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                // Select some images for testing
                containers[1].querySelector('.select-checkbox').checked = true;
                containers[1].classList.add('selected');
                containers[3].querySelector('.select-checkbox').checked = true;
                containers[3].classList.add('selected');
                containers[7].querySelector('.select-checkbox').checked = true;
                containers[7].classList.add('selected');
            });

            describe('Toggle Functionality', function() {
                it('should show only selected images when activated', function() {
                    // Simulate toggle activation
                    isSelectedMode = true;
                    toggleButton.setAttribute('aria-pressed', 'true');
                    toggleButton.querySelector('.show-selected-text').style.display = 'none';
                    toggleButton.querySelector('.show-all-text').style.display = 'inline';
                    statusBar.classList.add('selected-mode');

                    // Filter images (simulating filterImages function)
                    containers.forEach((container, i) => {
                        const isSelected = container.classList.contains('selected');
                        container.style.display = (isSelectedMode && isSelected) ? 'flex' :
                                                  (isSelectedMode && !isSelected) ? 'none' : 'flex';
                    });

                    // Verify only selected images are visible
                    expect(containers[1].style.display).to.equal('flex');
                    expect(containers[3].style.display).to.equal('flex');
                    expect(containers[7].style.display).to.equal('flex');
                    expect(containers[0].style.display).to.equal('none');
                    expect(containers[2].style.display).to.equal('none');
                });

                it('should update button aria-pressed state', function() {
                    toggleButton.setAttribute('aria-pressed', 'true');
                    expect(toggleButton.getAttribute('aria-pressed')).to.equal('true');

                    toggleButton.setAttribute('aria-pressed', 'false');
                    expect(toggleButton.getAttribute('aria-pressed')).to.equal('false');
                });

                it('should toggle button text correctly', function() {
                    const showSelectedText = toggleButton.querySelector('.show-selected-text');
                    const showAllText = toggleButton.querySelector('.show-all-text');

                    // Activate
                    showSelectedText.style.display = 'none';
                    showAllText.style.display = 'inline';

                    expect(window.getComputedStyle(showSelectedText).display).to.equal('none');
                    expect(window.getComputedStyle(showAllText).display).to.equal('inline');

                    // Deactivate
                    showSelectedText.style.display = 'inline';
                    showAllText.style.display = 'none';

                    expect(window.getComputedStyle(showSelectedText).display).to.equal('inline');
                    expect(window.getComputedStyle(showAllText).display).to.equal('none');
                });

                it('should update status bar class', function() {
                    statusBar.classList.add('selected-mode');
                    expect(statusBar.classList.contains('selected-mode')).to.be.true;

                    statusBar.classList.remove('selected-mode');
                    expect(statusBar.classList.contains('selected-mode')).to.be.false;
                });

                it('should show correct count in badge', function() {
                    const badge = toggleButton.querySelector('.selected-count-badge');
                    const selectedCount = 3;

                    badge.style.display = 'flex';
                    badge.textContent = selectedCount;
                    badge.setAttribute('aria-label', `${selectedCount} selected images`);

                    expect(badge.textContent).to.equal('3');
                    expect(badge.getAttribute('aria-label')).to.equal('3 selected images');
                    expect(window.getComputedStyle(badge).display).to.equal('flex');
                });

                it('should hide badge when no selections', function() {
                    const badge = toggleButton.querySelector('.selected-count-badge');
                    badge.style.display = 'none';

                    expect(window.getComputedStyle(badge).display).to.equal('none');
                });
            });

            describe('Integration with Filters', function() {
                it('should work with orientation filters', function() {
                    // Set some containers to portrait, some to landscape
                    containers[0].setAttribute('data-orientation', 'portrait');
                    containers[1].setAttribute('data-orientation', 'landscape');
                    containers[3].setAttribute('data-orientation', 'portrait');

                    isSelectedMode = true;

                    // Apply both selected mode and orientation filter
                    const orientationFilter = 'landscape';
                    containers.forEach(container => {
                        const isSelected = container.classList.contains('selected');
                        const orientation = container.getAttribute('data-orientation');
                        const orientationMatch = (orientation === orientationFilter);
                        const selectedMatch = isSelectedMode ? isSelected : true;

                        container.style.display = (orientationMatch && selectedMatch) ? 'flex' : 'none';
                    });

                    // Only container 1 should be visible (landscape AND selected)
                    expect(containers[1].style.display).to.equal('flex');
                    expect(containers[0].style.display).to.equal('none'); // portrait
                    expect(containers[3].style.display).to.equal('none'); // portrait
                });

                it('should show all selected images when no other filters active', function() {
                    isSelectedMode = true;

                    containers.forEach(container => {
                        const isSelected = container.classList.contains('selected');
                        container.style.display = isSelected ? 'flex' : 'none';
                    });

                    const visibleCount = containers.filter(c => c.style.display === 'flex').length;
                    expect(visibleCount).to.equal(3); // 3 selected images
                });
            });

            describe('Mutual Exclusivity with Hidden Mode', function() {
                it('should exit hidden mode when entering selected mode', function() {
                    // Simulate hidden mode active
                    let isHiddenMode = true;
                    const hiddenToggleButton = document.createElement('button');
                    hiddenToggleButton.id = 'toggle-hidden-mode';
                    hiddenToggleButton.setAttribute('aria-pressed', 'true');
                    fixtures.appendChild(hiddenToggleButton);

                    // Enter selected mode
                    isSelectedMode = true;
                    if (isSelectedMode && isHiddenMode) {
                        isHiddenMode = false;
                        hiddenToggleButton.setAttribute('aria-pressed', 'false');
                        statusBar.classList.remove('hidden-mode');
                    }

                    expect(isHiddenMode).to.be.false;
                    expect(hiddenToggleButton.getAttribute('aria-pressed')).to.equal('false');
                    expect(statusBar.classList.contains('hidden-mode')).to.be.false;
                });

                it('should exit selected mode when entering hidden mode', function() {
                    // Start in selected mode
                    isSelectedMode = true;
                    toggleButton.setAttribute('aria-pressed', 'true');
                    statusBar.classList.add('selected-mode');

                    // Enter hidden mode
                    let isHiddenMode = true;
                    if (isHiddenMode && isSelectedMode) {
                        isSelectedMode = false;
                        toggleButton.setAttribute('aria-pressed', 'false');
                        statusBar.classList.remove('selected-mode');
                    }

                    expect(isSelectedMode).to.be.false;
                    expect(toggleButton.getAttribute('aria-pressed')).to.equal('false');
                    expect(statusBar.classList.contains('selected-mode')).to.be.false;
                });
            });
        });

        // =============================================================================
        // HIDE SELECTED FUNCTIONALITY
        // =============================================================================

        describe('Hide Selected Functionality', function() {
            let fixtures;
            let containers;
            let statusBar;
            let hideSelectedButton;
            let mockStorage;
            let hiddenImages = {};

            // Mock functions from gallery script
            function isImageHidden(imagePath) {
                return hiddenImages[imagePath] === true;
            }

            function hideImage(imagePath) {
                hiddenImages[imagePath] = true;
                const checkbox = document.querySelector(`[data-full-image="${imagePath}"] .select-checkbox`);
                if (checkbox && checkbox.checked) {
                    checkbox.checked = false;
                    checkbox.parentElement.classList.remove('selected');
                }
            }

            function getHiddenImagesCount() {
                return Object.keys(hiddenImages).filter(key => hiddenImages[key]).length;
            }

            function filterImages() {
                const imageContainers = document.querySelectorAll('.image-container');
                imageContainers.forEach(img => {
                    const imgPath = img.getAttribute('data-full-image');
                    const hiddenMatch = !isImageHidden(imgPath);
                    img.style.display = hiddenMatch ? 'flex' : 'none';
                });
            }

            function updateCounts() {
                const statusBarEl = document.getElementById('status-bar');
                if (!statusBarEl) return;
                const allContainers = document.querySelectorAll('.image-container');
                const totalImages = allContainers.length;
                const visibleCount = Array.from(allContainers).filter(c => c.style.display !== 'none').length;
                const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                statusBarEl.textContent = `Showing ${visibleCount} of ${totalImages} images | ${selectedCount} selected`;
            }

            function hideSelectedImages() {
                const imageContainers = document.querySelectorAll('.image-container');
                const selectedImages = [];

                imageContainers.forEach(container => {
                    if (container.style.display !== 'none') {
                        const checkbox = container.querySelector('.select-checkbox');
                        if (checkbox && checkbox.checked) {
                            const imagePath = container.getAttribute('data-full-image');
                            if (imagePath) {
                                selectedImages.push({ path: imagePath, container, checkbox });
                            }
                        }
                    }
                });

                if (selectedImages.length === 0) {
                    return 0;
                }

                selectedImages.forEach(item => {
                    hideImage(item.path);
                });

                updateCounts();
                filterImages();

                return selectedImages.length;
            }

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                TestHelpers.cleanup();

                // Reset state
                hiddenImages = {};

                // Create gallery
                containers = TestHelpers.createMockGallery(15);
                containers.forEach(c => fixtures.appendChild(c));

                // Create UI elements
                statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                // Create Hide Selected button
                hideSelectedButton = document.createElement('button');
                hideSelectedButton.id = 'hide-selected-photos';
                hideSelectedButton.textContent = 'Hide Selected';
                hideSelectedButton.setAttribute('aria-label', 'Hide all selected images from gallery');
                fixtures.appendChild(hideSelectedButton);

                // Mock localStorage
                mockStorage = TestHelpers.mockLocalStorage();
                window.localStorage = mockStorage;
            });

            afterEach(function() {
                TestHelpers.cleanup();
            });

            describe('Basic Functionality', function() {
                it('should hide all selected images', function() {
                    // Select 3 images
                    containers.slice(0, 3).forEach(c => {
                        const checkbox = c.querySelector('.select-checkbox');
                        checkbox.checked = true;
                    });

                    const hiddenCount = hideSelectedImages();

                    expect(hiddenCount).to.equal(3);
                    expect(getHiddenImagesCount()).to.equal(3);
                });

                it('should clear selections of hidden images', function() {
                    // Select 2 images
                    containers.slice(0, 2).forEach(c => {
                        const checkbox = c.querySelector('.select-checkbox');
                        checkbox.checked = true;
                        c.classList.add('selected');
                    });

                    hideSelectedImages();

                    // All selected checkboxes should now be unchecked
                    const checkedBoxes = fixtures.querySelectorAll('.select-checkbox:checked');
                    expect(checkedBoxes.length).to.equal(0);
                });

                it('should return 0 when no images are selected', function() {
                    const hiddenCount = hideSelectedImages();
                    expect(hiddenCount).to.equal(0);
                });

                it('should only hide visible images (respect filters)', function() {
                    // Select 5 images
                    containers.slice(0, 5).forEach(c => {
                        const checkbox = c.querySelector('.select-checkbox');
                        checkbox.checked = true;
                    });

                    // Hide 2 of them (simulating filter)
                    containers[1].style.display = 'none';
                    containers[3].style.display = 'none';

                    const hiddenCount = hideSelectedImages();

                    // Should only hide the 3 visible ones
                    expect(hiddenCount).to.equal(3);
                });

                it('should update status bar after hiding', function() {
                    containers.slice(0, 4).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    hideSelectedImages();

                    expect(statusBar.textContent).to.include('0 selected');
                });

                it('should hide images from gallery view', function() {
                    containers.slice(0, 3).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    hideSelectedImages();

                    // Verify images are hidden
                    const visibleImages = containers.filter(c => c.style.display === 'flex');
                    expect(visibleImages.length).to.equal(12); // 15 - 3 = 12
                });
            });

            describe('Bulk Operations', function() {
                it('should hide large number of selected images', function() {
                    // Select all 15 images
                    containers.forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    const hiddenCount = hideSelectedImages();

                    expect(hiddenCount).to.equal(15);
                    expect(getHiddenImagesCount()).to.equal(15);
                });

                it('should handle partial selections correctly', function() {
                    // Select every other image (7 images)
                    containers.forEach((c, i) => {
                        if (i % 2 === 0) {
                            c.querySelector('.select-checkbox').checked = true;
                        }
                    });

                    const hiddenCount = hideSelectedImages();

                    expect(hiddenCount).to.equal(8); // 15 / 2 rounded up
                });

                it('should handle hiding then unhiding workflow', function() {
                    containers.slice(0, 3).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    hideSelectedImages();
                    expect(getHiddenImagesCount()).to.equal(3);

                    // Unhide them
                    containers.slice(0, 3).forEach(c => {
                        const path = c.getAttribute('data-full-image');
                        delete hiddenImages[path];
                    });

                    expect(getHiddenImagesCount()).to.equal(0);
                });
            });

            describe('Edge Cases', function() {
                it('should handle repeated hide operations gracefully', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;

                    hideSelectedImages();
                    hideSelectedImages(); // Second call should be safe

                    expect(getHiddenImagesCount()).to.equal(1);
                });

                it('should handle empty gallery', function() {
                    // Remove all containers
                    containers.forEach(c => c.remove());

                    const hiddenCount = hideSelectedImages();
                    expect(hiddenCount).to.equal(0);
                });

                it('should preserve hidden state across operations', function() {
                    // Hide first 3
                    containers.slice(0, 3).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });
                    hideSelectedImages();

                    // Hide next 2
                    containers.slice(3, 5).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });
                    hideSelectedImages();

                    // Total should be 5
                    expect(getHiddenImagesCount()).to.equal(5);
                });
            });

            describe('Integration with Existing Features', function() {
                it('should work with selection persistence', function() {
                    containers.slice(0, 4).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    // Simulate saving to localStorage
                    const selections = {};
                    containers.slice(0, 4).forEach(c => {
                        const path = c.getAttribute('data-full-image');
                        selections[path] = true;
                    });

                    hideSelectedImages();

                    // Selections should be cleared for hidden images
                    const checkedBoxes = fixtures.querySelectorAll('.select-checkbox:checked');
                    expect(checkedBoxes.length).to.equal(0);
                });

                it('should update hidden count badge', function() {
                    const badge = document.createElement('span');
                    badge.className = 'hidden-count-badge';
                    badge.style.display = 'none';
                    fixtures.appendChild(badge);

                    containers.slice(0, 5).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    hideSelectedImages();

                    // Badge should be updated (in real implementation)
                    expect(getHiddenImagesCount()).to.equal(5);
                });

                it('should work with filters active', function() {
                    // Apply a filter (hide odd indices)
                    containers.forEach((c, i) => {
                        if (i % 2 === 1) {
                            c.style.display = 'none';
                        }
                    });

                    // Select all visible (even indices)
                    containers.forEach((c, i) => {
                        if (i % 2 === 0) {
                            c.querySelector('.select-checkbox').checked = true;
                        }
                    });

                    const hiddenCount = hideSelectedImages();

                    // Should only hide visible selected ones
                    expect(hiddenCount).to.equal(8);
                });
            });

            describe('Accessibility', function() {
                it('should have proper ARIA label on button', function() {
                    const button = document.getElementById('hide-selected-photos');
                    expect(button.getAttribute('aria-label')).to.equal('Hide all selected images from gallery');
                });

                it('should announce action to screen readers', function() {
                    const ariaLive = document.createElement('div');
                    ariaLive.id = 'aria-live-region';
                    ariaLive.setAttribute('aria-live', 'polite');
                    fixtures.appendChild(ariaLive);

                    containers.slice(0, 3).forEach(c => {
                        c.querySelector('.select-checkbox').checked = true;
                    });

                    hideSelectedImages();

                    // In real implementation, screen reader would announce
                    expect(getHiddenImagesCount()).to.equal(3);
                });
            });

            describe('UI Button State', function() {
                it('should be enabled when images are selected', function() {
                    containers[0].querySelector('.select-checkbox').checked = true;
                    const button = document.getElementById('hide-selected-photos');

                    // Button should be clickable
                    expect(button).to.exist;
                    expect(button.disabled).to.not.be.true;
                });

                it('should be visible in photo controls', function() {
                    const button = document.getElementById('hide-selected-photos');
                    expect(button).to.exist;
                    expect(button.textContent).to.equal('Hide Selected');
                });
            });
        });

        // =============================================================================
        // FLOATING HIDE BUTTON AND KEYBOARD SHORTCUT
        // =============================================================================

        describe('Floating Hide Button and Keyboard Shortcut', function() {
            let fixtures, containers, checkboxes;
            let floatingButton, floatingButtonContainer;

            // Mock functions
            const mockHideImage = function(imagePath) {
                const container = document.querySelector(`[data-full-image="${imagePath}"]`);
                if (container) {
                    container.style.display = 'none';
                }
            };

            const mockUpdateCounts = function() {
                const selectedCount = document.querySelectorAll('.select-checkbox:checked').length;
                window.updateFloatingHideButton(selectedCount);
            };

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                fixtures.innerHTML = '';

                // Create floating hide button
                floatingButtonContainer = document.createElement('div');
                floatingButtonContainer.className = 'floating-hide-button';
                floatingButtonContainer.id = 'floating-hide-button';
                floatingButtonContainer.style.display = 'none';

                const button = document.createElement('button');
                button.type = 'button';
                button.id = 'floating-hide-selected';
                button.setAttribute('aria-label', 'Hide selected images (Shift+H)');
                button.innerHTML = '<span aria-hidden="true">👁️‍🗨️</span> Hide Selected';

                floatingButtonContainer.appendChild(button);
                fixtures.appendChild(floatingButtonContainer);

                floatingButton = button;

                // Create test images
                containers = [];
                checkboxes = [];
                for (let i = 0; i < 5; i++) {
                    const container = document.createElement('div');
                    container.className = 'image-container';
                    container.setAttribute('data-full-image', `image${i}.jpg`);

                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'select-checkbox';

                    container.appendChild(checkbox);
                    fixtures.appendChild(container);
                    containers.push(container);
                    checkboxes.push(checkbox);
                }

                // Mock window.hideImage
                window.hideImage = mockHideImage;
                window.updateFloatingHideButton = function(count) {
                    if (count > 0) {
                        floatingButtonContainer.style.display = 'block';
                    } else {
                        floatingButtonContainer.style.display = 'none';
                    }
                };
            });

            afterEach(function() {
                delete window.hideImage;
                delete window.updateFloatingHideButton;
            });

            describe('Button Visibility', function() {
                it('should be hidden when no images are selected', function() {
                    mockUpdateCounts();
                    expect(floatingButtonContainer.style.display).to.equal('none');
                });

                it('should be visible when images are selected', function() {
                    checkboxes[0].checked = true;
                    mockUpdateCounts();
                    expect(floatingButtonContainer.style.display).to.equal('block');
                });

                it('should hide when all selections are cleared', function() {
                    checkboxes[0].checked = true;
                    checkboxes[1].checked = true;
                    mockUpdateCounts();
                    expect(floatingButtonContainer.style.display).to.equal('block');

                    checkboxes[0].checked = false;
                    checkboxes[1].checked = false;
                    mockUpdateCounts();
                    expect(floatingButtonContainer.style.display).to.equal('none');
                });

                it('should remain visible when some selections remain', function() {
                    checkboxes[0].checked = true;
                    checkboxes[1].checked = true;
                    mockUpdateCounts();

                    checkboxes[0].checked = false;
                    mockUpdateCounts();
                    expect(floatingButtonContainer.style.display).to.equal('block');
                });
            });

            describe('Button Click Functionality', function() {
                it('should hide all selected images when clicked', function() {
                    checkboxes[0].checked = true;
                    checkboxes[2].checked = true;

                    floatingButton.click();

                    expect(containers[0].style.display).to.equal('none');
                    expect(containers[2].style.display).to.equal('none');
                    expect(containers[1].style.display).to.not.equal('none');
                });

                it('should work identically to regular hide button', function() {
                    checkboxes[1].checked = true;
                    checkboxes[3].checked = true;

                    floatingButton.click();

                    expect(containers[1].style.display).to.equal('none');
                    expect(containers[3].style.display).to.equal('none');
                });
            });

            describe('Keyboard Shortcut (Shift+H)', function() {
                it('should trigger hide when Shift+H is pressed', function() {
                    checkboxes[0].checked = true;

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    expect(containers[0].style.display).to.equal('none');
                });

                it('should not trigger without Shift key', function() {
                    checkboxes[0].checked = true;

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: false,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    expect(containers[0].style.display).to.not.equal('none');
                });

                it('should not trigger when typing in input field', function() {
                    checkboxes[0].checked = true;

                    const input = document.createElement('input');
                    input.type = 'text';
                    fixtures.appendChild(input);

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    input.dispatchEvent(event);

                    expect(containers[0].style.display).to.not.equal('none');
                });

                it('should do nothing if no images are selected', function() {
                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    containers.forEach(container => {
                        expect(container.style.display).to.not.equal('none');
                    });
                });

                it('should hide multiple selected images', function() {
                    checkboxes[0].checked = true;
                    checkboxes[2].checked = true;
                    checkboxes[4].checked = true;

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    expect(containers[0].style.display).to.equal('none');
                    expect(containers[2].style.display).to.equal('none');
                    expect(containers[4].style.display).to.equal('none');
                    expect(containers[1].style.display).to.not.equal('none');
                    expect(containers[3].style.display).to.not.equal('none');
                });
            });

            describe('Accessibility', function() {
                it('should have proper ARIA label mentioning keyboard shortcut', function() {
                    const ariaLabel = floatingButton.getAttribute('aria-label');
                    expect(ariaLabel).to.include('Shift+H');
                });

                it('should have eye icon for visual indication', function() {
                    const iconSpan = floatingButton.querySelector('[aria-hidden="true"]');
                    expect(iconSpan).to.exist;
                    expect(iconSpan.textContent).to.include('👁️');
                });

                it('should have descriptive button text', function() {
                    expect(floatingButton.textContent).to.include('Hide Selected');
                });
            });

            describe('Integration with Existing Features', function() {
                it('should work with filter-aware hide functionality', function() {
                    // Filter out some images
                    containers[1].style.display = 'none';
                    containers[3].style.display = 'none';

                    // Select all images (including filtered ones)
                    checkboxes.forEach(cb => cb.checked = true);

                    floatingButton.click();

                    // Only visible selected images should be hidden
                    expect(containers[0].style.display).to.equal('none');
                    expect(containers[2].style.display).to.equal('none');
                    expect(containers[4].style.display).to.equal('none');
                });

                it('should update visibility after bulk operations', function() {
                    // Initially hidden
                    expect(floatingButtonContainer.style.display).to.equal('none');

                    // Select multiple images
                    checkboxes[0].checked = true;
                    checkboxes[1].checked = true;
                    checkboxes[2].checked = true;
                    mockUpdateCounts();

                    // Button should be visible
                    expect(floatingButtonContainer.style.display).to.equal('block');

                    // Deselect all
                    checkboxes.forEach(cb => cb.checked = false);
                    mockUpdateCounts();

                    // Button should hide again
                    expect(floatingButtonContainer.style.display).to.equal('none');
                });

                it('should not interfere with modal keyboard shortcuts', function() {
                    // This test ensures Shift+H only works when modal is not open
                    const modal = document.createElement('div');
                    modal.id = 'image-modal';
                    modal.className = 'modal';
                    fixtures.appendChild(modal);

                    checkboxes[0].checked = true;

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    // Should still work (modal shortcuts are different)
                    expect(containers[0].style.display).to.equal('none');
                });
            });

            describe('Performance and Edge Cases', function() {
                it('should handle rapid keyboard shortcut presses', function() {
                    checkboxes[0].checked = true;

                    for (let i = 0; i < 5; i++) {
                        const event = new KeyboardEvent('keydown', {
                            key: 'H',
                            shiftKey: true,
                            bubbles: true
                        });
                        document.dispatchEvent(event);
                    }

                    expect(containers[0].style.display).to.equal('none');
                });

                it('should handle button and keyboard shortcut together', function() {
                    checkboxes[0].checked = true;
                    checkboxes[1].checked = true;

                    floatingButton.click();

                    checkboxes[2].checked = true;

                    const event = new KeyboardEvent('keydown', {
                        key: 'H',
                        shiftKey: true,
                        bubbles: true
                    });
                    document.dispatchEvent(event);

                    expect(containers[0].style.display).to.equal('none');
                    expect(containers[1].style.display).to.equal('none');
                    expect(containers[2].style.display).to.equal('none');
                });

                it('should position button correctly (CSS class exists)', function() {
                    expect(floatingButtonContainer.className).to.equal('floating-hide-button');
                    expect(floatingButton.id).to.equal('floating-hide-selected');
                });
            });
        });

        // =============================================================================
        // SHIFT-SELECT RANGE FUNCTIONALITY
        // =============================================================================

        describe('Shift-Select Range Selection', function() {
            let fixtures, containers, checkboxes;
            let lastSelectedIndex;

            beforeEach(function() {
                lastSelectedIndex = -1;

                fixtures = document.getElementById('test-fixtures');
                fixtures.innerHTML = '';

                // Create notification bar
                const notificationBar = TestHelpers.createNotificationBar();
                fixtures.appendChild(notificationBar);

                // Create status bar
                const statusBar = TestHelpers.createStatusBar();
                fixtures.appendChild(statusBar);

                // Create gallery containers
                containers = TestHelpers.createMockGallery(10);
                containers.forEach(c => fixtures.appendChild(c));

                checkboxes = containers.map(c => c.querySelector('.select-checkbox'));
            });

            /**
             * Simulate the selectRange function
             */
            function selectRange(startIndex, endIndex, checked) {
                const allCheckboxes = Array.from(document.querySelectorAll('.select-checkbox'));
                const visibleCheckboxes = allCheckboxes.filter(cb => {
                    return cb.parentElement.style.display !== 'none';
                });

                const start = Math.min(startIndex, endIndex);
                const end = Math.max(startIndex, endIndex);

                for (let i = start; i <= end; i++) {
                    if (i >= 0 && i < visibleCheckboxes.length) {
                        const checkbox = visibleCheckboxes[i];
                        checkbox.checked = checked;
                        if (checked) {
                            checkbox.parentElement.classList.add('selected');
                        } else {
                            checkbox.parentElement.classList.remove('selected');
                        }
                    }
                }

                return Math.abs(end - start) + 1; // Return count
            }

            describe('Basic Range Selection', function() {
                it('should select range from index 0 to 3', function() {
                    // Click first checkbox
                    checkboxes[0].checked = true;
                    containers[0].classList.add('selected');
                    lastSelectedIndex = 0;

                    // Shift-click fourth checkbox
                    selectRange(lastSelectedIndex, 3, true);

                    // Verify range is selected
                    expect(checkboxes[0].checked).to.be.true;
                    expect(checkboxes[1].checked).to.be.true;
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[3].checked).to.be.true;
                    expect(checkboxes[4].checked).to.be.false;
                });

                it('should work in reverse direction (high to low index)', function() {
                    // Click checkbox at index 5
                    checkboxes[5].checked = true;
                    containers[5].classList.add('selected');
                    lastSelectedIndex = 5;

                    // Shift-click checkbox at index 2 (lower index)
                    selectRange(lastSelectedIndex, 2, true);

                    // Verify range is selected
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[3].checked).to.be.true;
                    expect(checkboxes[4].checked).to.be.true;
                    expect(checkboxes[5].checked).to.be.true;
                    expect(checkboxes[1].checked).to.be.false;
                    expect(checkboxes[6].checked).to.be.false;
                });

                it('should update visual selection state', function() {
                    lastSelectedIndex = 1;
                    selectRange(lastSelectedIndex, 3, true);

                    expect(containers[1].classList.contains('selected')).to.be.true;
                    expect(containers[2].classList.contains('selected')).to.be.true;
                    expect(containers[3].classList.contains('selected')).to.be.true;
                });

                it('should return correct count', function() {
                    const count = selectRange(2, 6, true);
                    expect(count).to.equal(5); // Indices 2, 3, 4, 5, 6 = 5 images
                });
            });

            describe('Deselection Range', function() {
                beforeEach(function() {
                    // Pre-select all checkboxes
                    checkboxes.forEach((cb, i) => {
                        cb.checked = true;
                        containers[i].classList.add('selected');
                    });
                });

                it('should deselect range when checked=false', function() {
                    lastSelectedIndex = 1;
                    selectRange(lastSelectedIndex, 4, false);

                    expect(checkboxes[0].checked).to.be.true; // Outside range
                    expect(checkboxes[1].checked).to.be.false;
                    expect(checkboxes[2].checked).to.be.false;
                    expect(checkboxes[3].checked).to.be.false;
                    expect(checkboxes[4].checked).to.be.false;
                    expect(checkboxes[5].checked).to.be.true; // Outside range
                });

                it('should remove selected class when deselecting', function() {
                    lastSelectedIndex = 0;
                    selectRange(lastSelectedIndex, 2, false);

                    expect(containers[0].classList.contains('selected')).to.be.false;
                    expect(containers[1].classList.contains('selected')).to.be.false;
                    expect(containers[2].classList.contains('selected')).to.be.false;
                });
            });

            describe('Anchor Point Behavior', function() {
                it('should keep anchor fixed during multiple shift-selects', function() {
                    // Set anchor at index 2
                    checkboxes[2].checked = true;
                    containers[2].classList.add('selected');
                    lastSelectedIndex = 2;

                    // Shift-select to index 5
                    selectRange(lastSelectedIndex, 5, true);
                    // Anchor should stay at 2 (not move to 5)

                    // Verify range 2-5 is selected
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[3].checked).to.be.true;
                    expect(checkboxes[4].checked).to.be.true;
                    expect(checkboxes[5].checked).to.be.true;

                    // Shift-select to index 7 (still from anchor 2)
                    selectRange(lastSelectedIndex, 7, true);

                    // Verify range 2-7 is selected
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[6].checked).to.be.true;
                    expect(checkboxes[7].checked).to.be.true;
                });

                it('should allow shrinking selection from anchor', function() {
                    lastSelectedIndex = 1;

                    // Extend to index 6
                    selectRange(lastSelectedIndex, 6, true);
                    expect(checkboxes[6].checked).to.be.true;

                    // Shrink to index 3 (still from anchor 1)
                    selectRange(lastSelectedIndex, 3, true);

                    // Range 1-3 should be selected
                    expect(checkboxes[1].checked).to.be.true;
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[3].checked).to.be.true;
                });
            });

            describe('Filtered Images (Visible Only)', function() {
                beforeEach(function() {
                    // Hide every other container to simulate filtering
                    containers[1].style.display = 'none';
                    containers[3].style.display = 'none';
                    containers[5].style.display = 'none';
                    containers[7].style.display = 'none';
                    containers[9].style.display = 'none';
                });

                it('should only select visible checkboxes', function() {
                    // Visible indices: 0, 2, 4, 6, 8
                    // In visible array: [0, 1, 2, 3, 4]

                    const visibleCheckboxes = checkboxes.filter((cb, i) =>
                        containers[i].style.display !== 'none'
                    );

                    // Select visible range 0-2 (which maps to containers 0, 2, 4)
                    lastSelectedIndex = 0;
                    selectRange(lastSelectedIndex, 2, true);

                    // Check that hidden containers weren't selected
                    expect(checkboxes[1].checked).to.be.false; // Hidden
                    expect(checkboxes[3].checked).to.be.false; // Hidden
                });

                it('should calculate range based on visible indices only', function() {
                    // After filtering, visible containers are: 0, 2, 4, 6, 8
                    const count = selectRange(0, 3, true); // Select 4 visible images
                    expect(count).to.equal(4);
                });
            });

            describe('Edge Cases', function() {
                it('should handle single-item range', function() {
                    const count = selectRange(3, 3, true);
                    expect(count).to.equal(1);
                    expect(checkboxes[3].checked).to.be.true;
                });

                it('should handle range to last item', function() {
                    lastSelectedIndex = 7;
                    selectRange(lastSelectedIndex, 9, true);

                    expect(checkboxes[7].checked).to.be.true;
                    expect(checkboxes[8].checked).to.be.true;
                    expect(checkboxes[9].checked).to.be.true;
                });

                it('should handle range from first item', function() {
                    lastSelectedIndex = 0;
                    selectRange(lastSelectedIndex, 2, true);

                    expect(checkboxes[0].checked).to.be.true;
                    expect(checkboxes[1].checked).to.be.true;
                    expect(checkboxes[2].checked).to.be.true;
                });

                it('should not select out of bounds indices', function() {
                    // Try to select beyond array bounds
                    const count = selectRange(8, 15, true);

                    // Should only select valid indices
                    expect(checkboxes[8].checked).to.be.true;
                    expect(checkboxes[9].checked).to.be.true;
                });
            });

            describe('Image Click Integration', function() {
                it('should support shift-clicking images (not just checkboxes)', function() {
                    // First click on image (not checkbox)
                    const img1 = containers[1].querySelector('img');
                    const checkbox1 = containers[1].querySelector('.select-checkbox');

                    checkbox1.checked = true;
                    containers[1].classList.add('selected');
                    lastSelectedIndex = 1;

                    // Shift-click on another image
                    // This should trigger selectRange
                    selectRange(lastSelectedIndex, 4, true);

                    expect(checkboxes[1].checked).to.be.true;
                    expect(checkboxes[2].checked).to.be.true;
                    expect(checkboxes[3].checked).to.be.true;
                    expect(checkboxes[4].checked).to.be.true;
                });
            });
        });

        // =============================================================================
        // INTEGRATION TESTS - COMBINED FEATURES
        // =============================================================================

        describe('Integration: Selected Mode + Shift-Select', function() {
            let fixtures, containers, toggleButton;
            let isSelectedMode, lastSelectedIndex;

            beforeEach(function() {
                isSelectedMode = false;
                lastSelectedIndex = -1;

                fixtures = document.getElementById('test-fixtures');
                fixtures.innerHTML = '';

                // Create toggle button
                const viewModeControls = document.createElement('div');
                toggleButton = document.createElement('button');
                toggleButton.id = 'toggle-selected-mode';
                toggleButton.setAttribute('aria-pressed', 'false');
                const badge = document.createElement('span');
                badge.className = 'selected-count-badge';
                toggleButton.appendChild(badge);
                viewModeControls.appendChild(toggleButton);
                fixtures.appendChild(viewModeControls);

                // Create status bar and notification
                fixtures.appendChild(TestHelpers.createStatusBar());
                fixtures.appendChild(TestHelpers.createNotificationBar());

                // Create gallery
                containers = TestHelpers.createMockGallery(15);
                containers.forEach(c => fixtures.appendChild(c));
            });

            /**
             * Simulate selectRange function
             */
            function selectRange(startIndex, endIndex, checked) {
                const allCheckboxes = Array.from(document.querySelectorAll('.select-checkbox'));
                const visibleCheckboxes = allCheckboxes.filter(cb =>
                    cb.parentElement.style.display !== 'none'
                );

                const start = Math.min(startIndex, endIndex);
                const end = Math.max(startIndex, endIndex);

                for (let i = start; i <= end; i++) {
                    if (i >= 0 && i < visibleCheckboxes.length) {
                        const checkbox = visibleCheckboxes[i];
                        checkbox.checked = checked;
                        if (checked) {
                            checkbox.parentElement.classList.add('selected');
                        } else {
                            checkbox.parentElement.classList.remove('selected');
                        }
                    }
                }
            }

            /**
             * Simulate filterImages for selected mode
             */
            function filterForSelectedMode() {
                containers.forEach(container => {
                    const isSelected = container.classList.contains('selected');
                    container.style.display = (isSelectedMode && !isSelected) ? 'none' : 'flex';
                });
            }

            it('should work together: shift-select then enter selected mode', function() {
                // Use shift-select to select range 2-7
                lastSelectedIndex = 2;
                selectRange(lastSelectedIndex, 7, true);

                // Verify selection
                const checkboxes = containers.map(c => c.querySelector('.select-checkbox'));
                const selectedCount = checkboxes.filter(cb => cb.checked).length;
                expect(selectedCount).to.equal(6); // Indices 2-7 = 6 items

                // Enter selected mode
                isSelectedMode = true;
                filterForSelectedMode();

                // Verify only selected images are visible
                const visibleCount = containers.filter(c => c.style.display === 'flex').length;
                expect(visibleCount).to.equal(6);
            });

            it('should allow shift-select within selected mode', function() {
                // Pre-select some images: 0, 5, 6, 7, 12
                [0, 5, 6, 7, 12].forEach(i => {
                    containers[i].querySelector('.select-checkbox').checked = true;
                    containers[i].classList.add('selected');
                });

                // Enter selected mode
                isSelectedMode = true;
                filterForSelectedMode();

                // Now only 5 images are visible
                const visibleCount = containers.filter(c => c.style.display === 'flex').length;
                expect(visibleCount).to.equal(5);

                // Use shift-select within selected mode view
                // This should only affect visible (selected) images
                const visibleCheckboxes = Array.from(document.querySelectorAll('.select-checkbox'))
                    .filter(cb => cb.parentElement.style.display !== 'none');

                // Deselect range of visible items
                lastSelectedIndex = 1; // Second visible item (index 5 in full array)
                selectRange(lastSelectedIndex, 3, false); // Deselect 3 visible items

                // Verify deselection
                const stillSelectedCount = visibleCheckboxes.filter(cb => cb.checked).length;
                expect(stillSelectedCount).to.be.lessThan(5);
            });

            it('should update badge count after shift-select', function() {
                const badge = toggleButton.querySelector('.selected-count-badge');

                // Shift-select a range
                selectRange(0, 4, true);

                // Update badge
                const selectedCount = Array.from(document.querySelectorAll('.select-checkbox:checked')).length;
                badge.textContent = selectedCount;
                badge.style.display = 'flex';

                expect(badge.textContent).to.equal('5');
                expect(window.getComputedStyle(badge).display).to.equal('flex');
            });
        });

        // =============================================================================
        // EMPTY SLATE HIDING FUNCTIONALITY
        // =============================================================================

        describe('Empty Slate Hiding', function() {
            let fixtures, slates, containers;

            beforeEach(function() {
                fixtures = document.getElementById('test-fixtures');
                fixtures.innerHTML = '';

                // Create notification bar and status bar
                fixtures.appendChild(TestHelpers.createNotificationBar());
                fixtures.appendChild(TestHelpers.createStatusBar());

                // Create two slates with images
                slates = [];
                containers = [];

                // Slate 1: 5 images
                const slate1 = document.createElement('div');
                slate1.className = 'slate';
                const slate1Header = document.createElement('div');
                slate1Header.className = 'slate-header';
                const slate1Title = document.createElement('h2');
                slate1Title.textContent = 'A001A';
                slate1Header.appendChild(slate1Title);
                slate1.appendChild(slate1Header);

                const slate1Images = document.createElement('div');
                slate1Images.className = 'images';
                for (let i = 0; i < 5; i++) {
                    const container = TestHelpers.createImageContainer(
                        `/path/to/slate1/image${i}.jpg`,
                        'portrait',
                        '50',
                        '2025-01-15'
                    );
                    slate1Images.appendChild(container);
                    containers.push(container);
                }
                slate1.appendChild(slate1Images);
                slates.push(slate1);
                fixtures.appendChild(slate1);

                // Slate 2: 5 images
                const slate2 = document.createElement('div');
                slate2.className = 'slate';
                const slate2Header = document.createElement('div');
                slate2Header.className = 'slate-header';
                const slate2Title = document.createElement('h2');
                slate2Title.textContent = 'A002A';
                slate2Header.appendChild(slate2Title);
                slate2.appendChild(slate2Header);

                const slate2Images = document.createElement('div');
                slate2Images.className = 'images';
                for (let i = 0; i < 5; i++) {
                    const container = TestHelpers.createImageContainer(
                        `/path/to/slate2/image${i}.jpg`,
                        'landscape',
                        '85',
                        '2025-01-16'
                    );
                    slate2Images.appendChild(container);
                    containers.push(container);
                }
                slate2.appendChild(slate2Images);
                slates.push(slate2);
                fixtures.appendChild(slate2);
            });

            /**
             * Simulate filterImages function's slate hiding logic
             */
            function hideEmptySlates() {
                const allSlates = document.querySelectorAll('.slate');
                allSlates.forEach(function(slate) {
                    const slateImages = slate.querySelectorAll('.image-container');
                    let hasVisibleImages = false;

                    for (let i = 0; i < slateImages.length; i++) {
                        if (slateImages[i].style.display !== 'none') {
                            hasVisibleImages = true;
                            break;
                        }
                    }

                    if (hasVisibleImages) {
                        slate.style.display = 'block';
                    } else {
                        slate.style.display = 'none';
                    }
                });
            }

            describe('Basic Functionality', function() {
                it('should show slates with visible images', function() {
                    // All images visible
                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('block');
                    expect(slates[1].style.display).to.equal('block');
                });

                it('should hide slate when all images are filtered out', function() {
                    // Hide all images in first slate
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none');
                    expect(slates[1].style.display).to.equal('block');
                });

                it('should hide multiple slates when empty', function() {
                    // Hide all images in both slates
                    containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none');
                    expect(slates[1].style.display).to.equal('none');
                });

                it('should show slate again when images become visible', function() {
                    // Initially hide all images in first slate
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();
                    expect(slates[0].style.display).to.equal('none');

                    // Make images visible again
                    slate1Containers.forEach(container => {
                        container.style.display = 'flex';
                    });

                    hideEmptySlates();
                    expect(slates[0].style.display).to.equal('block');
                });
            });

            describe('Filter Integration', function() {
                it('should hide slate when orientation filter removes all images', function() {
                    // Slate 1 has portrait, Slate 2 has landscape
                    // Filter to show only landscape (hide all portrait)
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        const orientation = container.getAttribute('data-orientation');
                        if (orientation === 'portrait') {
                            container.style.display = 'none';
                        }
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none'); // All portrait
                    expect(slates[1].style.display).to.equal('block'); // All landscape
                });

                it('should hide slate when focal length filter removes all images', function() {
                    // Slate 1 has 50mm, Slate 2 has 85mm
                    // Filter to show only 50mm
                    const slate2Containers = slates[1].querySelectorAll('.image-container');
                    slate2Containers.forEach(container => {
                        const focalLength = container.getAttribute('data-focal-length');
                        if (focalLength === '85') {
                            container.style.display = 'none';
                        }
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('block'); // Has 50mm
                    expect(slates[1].style.display).to.equal('none'); // All 85mm filtered out
                });

                it('should hide slate when date filter removes all images', function() {
                    // Slate 1 has 2025-01-15, Slate 2 has 2025-01-16
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        const date = container.getAttribute('data-date');
                        if (date.startsWith('2025-01-15')) {
                            container.style.display = 'none';
                        }
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none'); // All 2025-01-15 filtered
                    expect(slates[1].style.display).to.equal('block'); // Has 2025-01-16
                });
            });

            describe('Hidden Images Mode Integration', function() {
                it('should hide slate when all images are hidden', function() {
                    // Simulate hiding all images in slate 1
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        container.style.display = 'none'; // Hidden by hidden images filter
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none');
                    expect(slates[1].style.display).to.equal('block');
                });

                it('should show slate in hidden mode when it has hidden images', function() {
                    // In hidden mode, only hidden images are visible
                    // Hide slate 2's images (not hidden), show slate 1's (hidden)
                    const slate2Containers = slates[1].querySelectorAll('.image-container');
                    slate2Containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('block'); // Has visible hidden images
                    expect(slates[1].style.display).to.equal('none'); // No hidden images
                });
            });

            describe('Selected Mode Integration', function() {
                it('should hide slate when all images are unselected in selected mode', function() {
                    // In selected mode, only selected images are visible
                    // Hide all images in slate 1 (none selected)
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('none');
                    expect(slates[1].style.display).to.equal('block');
                });

                it('should show slate with at least one selected image', function() {
                    // Select one image in slate 1, hide the rest
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach((container, i) => {
                        if (i === 0) {
                            container.style.display = 'flex'; // Selected
                            container.classList.add('selected');
                        } else {
                            container.style.display = 'none'; // Not selected
                        }
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('block'); // Has one selected
                });
            });

            describe('Combined Filters', function() {
                it('should handle multiple filters correctly', function() {
                    // Apply orientation filter (portrait only) + hide some images
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    const slate2Containers = slates[1].querySelectorAll('.image-container');

                    // Slate 1: portrait, keep 2 visible
                    slate1Containers.forEach((container, i) => {
                        container.style.display = i < 2 ? 'flex' : 'none';
                    });

                    // Slate 2: landscape, all hidden by orientation filter
                    slate2Containers.forEach(container => {
                        container.style.display = 'none';
                    });

                    hideEmptySlates();

                    expect(slates[0].style.display).to.equal('block'); // Has 2 visible
                    expect(slates[1].style.display).to.equal('none'); // All filtered
                });
            });

            describe('Edge Cases', function() {
                it('should handle slate with single image', function() {
                    // Remove all but one image from slate 1
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    for (let i = 1; i < slate1Containers.length; i++) {
                        slate1Containers[i].remove();
                    }

                    hideEmptySlates();
                    expect(slates[0].style.display).to.equal('block');

                    // Hide the single image
                    slate1Containers[0].style.display = 'none';
                    hideEmptySlates();
                    expect(slates[0].style.display).to.equal('none');
                });

                it('should handle empty slate (no images)', function() {
                    // Create slate with no images
                    const emptySlate = document.createElement('div');
                    emptySlate.className = 'slate';
                    const emptyImages = document.createElement('div');
                    emptyImages.className = 'images';
                    emptySlate.appendChild(emptyImages);
                    fixtures.appendChild(emptySlate);

                    hideEmptySlates();

                    expect(emptySlate.style.display).to.equal('none');
                });

                it('should handle rapid filter changes', function() {
                    const slate1Containers = slates[0].querySelectorAll('.image-container');

                    // Toggle visibility multiple times
                    for (let i = 0; i < 5; i++) {
                        slate1Containers.forEach(c => c.style.display = 'none');
                        hideEmptySlates();
                        expect(slates[0].style.display).to.equal('none');

                        slate1Containers.forEach(c => c.style.display = 'flex');
                        hideEmptySlates();
                        expect(slates[0].style.display).to.equal('block');
                    }
                });
            });

            describe('Visual Clutter Reduction', function() {
                it('should hide slate header when slate is hidden', function() {
                    const slate1Containers = slates[0].querySelectorAll('.image-container');
                    slate1Containers.forEach(c => c.style.display = 'none');

                    hideEmptySlates();

                    // When slate is hidden, header is also hidden
                    expect(slates[0].style.display).to.equal('none');
                    const header = slates[0].querySelector('.slate-header');
                    expect(header).to.not.be.null;
                });

                it('should reduce visual clutter with many empty slates', function() {
                    // Create 5 more slates, all empty
                    for (let i = 0; i < 5; i++) {
                        const slate = document.createElement('div');
                        slate.className = 'slate';
                        const images = document.createElement('div');
                        images.className = 'images';
                        // Add images but hide them all
                        for (let j = 0; j < 3; j++) {
                            const container = TestHelpers.createImageContainer(
                                `/path/slate${i}/img${j}.jpg`,
                                'portrait',
                                '50',
                                '2025-01-01'
                            );
                            container.style.display = 'none';
                            images.appendChild(container);
                        }
                        slate.appendChild(images);
                        fixtures.appendChild(slate);
                    }

                    hideEmptySlates();

                    // Count visible slates
                    const allSlates = document.querySelectorAll('.slate');
                    const visibleSlates = Array.from(allSlates).filter(
                        s => s.style.display !== 'none'
                    );

                    // Only slates with visible images should be shown
                    expect(visibleSlates.length).to.equal(2); // Original 2 slates
                });
            });
        });

        // =============================================================================
        // RUN TESTS
        // =============================================================================

        // Run the tests
        mocha.run();
    </script>
</body>
</html>
